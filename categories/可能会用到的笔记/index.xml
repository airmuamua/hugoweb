<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>可能会用到的笔记 on Skye</title>
        <link>https://airmuamua.github.io/hugoweb/categories/%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 可能会用到的笔记 on Skye</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>空气炸锅中-Skye</copyright>
        <lastBuildDate>Wed, 24 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://airmuamua.github.io/hugoweb/categories/%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【Web】Web开发-B/S架构</title>
        <link>https://airmuamua.github.io/hugoweb/p/b023/</link>
        <pubDate>Wed, 24 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b023/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%8F%E5%A4%A9%E6%A3%AE%E6%9E%97-%E5%A4%A7%E6%A0%91%E4%BB%B0%E6%8B%8D.png" alt="Featured image of post 【Web】Web开发-B/S架构" /&gt;&lt;h1 id=&#34;web开发通识课-bs架构软件&#34;&gt;Web开发通识课-B/S架构软件
&lt;/h1&gt;&lt;h2 id=&#34;简言&#34;&gt;简言
&lt;/h2&gt;&lt;p&gt;现在我们来讲BS架构的预备课，这预备课的主要内容是告诉大家软件的世界不仅仅还CS架构还有BS架构。&lt;/p&gt;
&lt;p&gt;我们所说的开发Web项目，开发Web应用指的是什么——其实就是BS架构的软件&lt;/p&gt;
&lt;p&gt;那么BS架构软件究竟意味着什么，哎，我们这个课要讲一下BS架构软件发展的历程，现在的状况以及未来的展望。这都是我们要考虑的问题。&lt;/p&gt;
&lt;p&gt;我们这个课程不求就是说让你去追踪一语言，或者说追踪一个学习路径，没有这样的东西。学完这门课程你会发现这样东西都弱爆了。&lt;/p&gt;
&lt;p&gt;你看完这门课你基本上，我不敢说能什么怎么怎么样哈，但是至少比你在市面上看到那些书，不管是看到博客还是其他也好，几乎是没有人能提及的这些东西。&lt;/p&gt;
&lt;p&gt;我们这个课程主要说B/S架构是怎么开发，C/S架构不是我们的重点，因为C/S架构现在职位不是很多，基本上很少有人做C/S架构的软件。&lt;/p&gt;
&lt;p&gt;而且我们现在都知道，就是我们会考虑到跨平台的问题，我们会给大家强调。就是说很多很多的应用程序都可以做跨平台应用，我们做B/S架构的时候其实实际上也是相当于把C/S架构做完了。我们之后会给大家再提到这个问题。&lt;/p&gt;
&lt;p&gt;那么这里再给大家去复习一下，我们之前学的内容。比如说C/S架构的软件&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【Web】Web开发-C/S架构</title>
        <link>https://airmuamua.github.io/hugoweb/p/b024/</link>
        <pubDate>Wed, 24 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b024/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%8F%E5%A4%A9%E6%A3%AE%E6%9E%97-%E5%A4%A7%E6%A0%91%E4%BB%B0%E6%8B%8D.png" alt="Featured image of post 【Web】Web开发-C/S架构" /&gt;&lt;h1 id=&#34;web开发通识课-cs架构软件&#34;&gt;Web开发通识课-C/S架构软件
&lt;/h1&gt;&lt;h2 id=&#34;cs-架构软件&#34;&gt;C/S 架构软件
&lt;/h2&gt;&lt;p&gt;C/S 架构软件是什么意思？&lt;/p&gt;
&lt;p&gt;client 客户端 需要下载 安装（QQ、微信、英雄联盟）&lt;/p&gt;
&lt;p&gt;server 服务端（QQ账号、iD账号、身份证、密码）&lt;/p&gt;
&lt;p&gt;C呢就相当于是客户端，S呢就相当于是服务端。&lt;/p&gt;
&lt;p&gt;这什么意思呢？什么叫客户端和服务端呢？&lt;/p&gt;
&lt;p&gt;很简单，你只需要打开**《英雄联盟》**，就明白我这个意思了。打开一个游戏就没白的的意思了，或者说打开微信就明白了，这叫C/S架构软件。&lt;/p&gt;
&lt;p&gt;你比如说你在电脑上登录微信，它就属于叫C/S 架构软件，啥意思呢？&lt;/p&gt;
&lt;p&gt;就是用户必须要下载这个软件，去安装。你们都从网上下载过软件嘛，下载——安装——下一步——下一步——下一步——安装成功，是吧，开始使用对吧。&lt;/p&gt;
&lt;p&gt;需要下载，要安装才能使用，这是客户端。最简单就是QQ、微信或者说是英雄联盟这种，这都是客户端。&lt;/p&gt;
&lt;p&gt;因为是客户嘛，客户要下载的东西，所以叫客户端。&lt;/p&gt;
&lt;p&gt;那服务端呢就是人家公司要有的东西，公司要有一个超级大电脑，这个电脑叫做服务器。这个服务器就是要管理服务端的，就相当于什么呢？它的服务端存放的东西就是QQ账号、iD账号、身份证以及你的密码这些东西。它要放到服务端上，就是你基本上不能看到的东西。&lt;/p&gt;
&lt;p&gt;相当于是客户与公司，与这些产品。比如说客户与QQ交互的这么样一个地方，就是服务端。&lt;/p&gt;
&lt;p&gt;比如说我在登录QQ的时候我要输入账号输入密码，我一点登录他有网，他就把账号密码发到腾讯那，腾讯检查，OK，是本人，让你登录，返回来。怎么样？从服务端返回来告诉你：哦，你可以登录。告诉客户端：行，你可以登录。就这么一个过程。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【数学】离散数学-1</title>
        <link>https://airmuamua.github.io/hugoweb/p/b022/</link>
        <pubDate>Mon, 22 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b022/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b022/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%8F%E5%A4%A9%E6%A3%AE%E6%9E%97-%E5%A4%A7%E6%A0%91%E4%BB%B0%E6%8B%8D.png" alt="Featured image of post 【数学】离散数学-1" /&gt;&lt;h1 id=&#34;离散数学与软件工程001逻辑命题-第一讲&#34;&gt;【离散数学与软件工程】001.逻辑命题 第一讲
&lt;/h1&gt;&lt;p&gt;那么我们现在呢，就来学第一章的内容。我们称之为叫逻辑学的基础。逻辑学呢，哎，我觉得，这个课还是要记笔记的啊。但是记笔记之前，我希望能够澄清一件事情，就是你一定要先听懂我在讲什么。听懂听完了再去记，你截个图，你不记都OK，我都不会说什么。&lt;/p&gt;
&lt;p&gt;那么逻辑（logic）逻辑听起来可能有些抽象，但是实际上它是让我们进行清晰思考，构建哪些有力的论证，编写计算机基础，一个非常非常基础的一个东西。很多人就是因为那些代码的if-else里边的这些东西，他没搞明白，就是各种各样的判断，他直接就晕了。他不明白为什么各种各样的判断啊，他就直接晕了。没有办法去理解，他理解这个东西，他判断这个东西他很困难，那这个就是逻辑上的欠缺。包括我们for语句当中每一次循环，他很容易就绕弯，很容易就晕了。就这个东西我们没有这样的教学，就很可惜。&lt;/p&gt;
&lt;p&gt;那么对于逻辑学第一章的内容，我跟大家介绍的，我们称之为叫做，&lt;strong&gt;命题逻辑（Propositional Logic）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;命题 Propositon&lt;/p&gt;
&lt;p&gt;定义：命题是一个陈述句，它要么是真 True,要么是假 False&lt;/p&gt;
&lt;p&gt;陈述句-&amp;gt; statement -&amp;gt; 说白了，它在陈述一个事实&lt;/p&gt;
&lt;p&gt;其次，这个陈述必须要有一个具体的明确的真值（true value），“或许”，“可能” ✕&lt;/p&gt;
&lt;p&gt;真 or 假&lt;/p&gt;
&lt;p&gt;第一个例子——海鸥会飞&lt;/p&gt;
&lt;p&gt;大家看这个句子，&lt;/p&gt;
&lt;p&gt;这个句子是一个陈述句吗？是的，明显啊。&lt;/p&gt;
&lt;p&gt;它有明确的真值吗？啊是的，对吧。&lt;/p&gt;
&lt;p&gt;我们知道海鸥确实会飞，所以我要考你，这个命题的真值是什么？true 因为海鸥真的会飞。&lt;/p&gt;
&lt;p&gt;你这句话但凡要改猪会飞，那这个情况这个命题真值肯定就是 false。&lt;/p&gt;
&lt;p&gt;OK，这是第一个啊，再看一个例子——2^2 + 3^2 = 4^2&lt;/p&gt;
&lt;p&gt;没看错啊，来我问你这个命题的真值是啥，这个很明显了是吧。这根本就不是，他妈根本不可能，这4 + 9 怎么就 = 16 呢。这根本就不可能，就是胡说八道。所以这个值肯定就是false。&lt;/p&gt;
&lt;p&gt;那么现在看一个非常有意思的一条案例——每一个正偶数都可以写成两个素数之和&lt;/p&gt;
&lt;p&gt;哎，这个好像有点难，不用关心，你不会算也没关系。&lt;/p&gt;
&lt;p&gt;来，我来问你，这句话它首先是不是一个statement，一个陈述句。那么它的真值是什么呢？现在我就有一个问题啊。其实这个就是哥德巴赫猜想，有数学好的同学应该猜得出来，你数学不好也没事。就是至今数学家还没有解决的一个难题，我们目前根本就不知道它的真假，但我们相信他肯定有一个值。什么值呢？就这句话要么这猜想是对的要么是错的。说白了就是这句话要么是真要么是假，不可能介于两者之间。所以他符合命题的定义。它符合命题的定义，但是我们没有办法知道他是真还是假。所以这个就要么是真要么是假，我们只能这样去确定。但首先它肯定是个命题，他肯定也是个陈述句。OK，这个重要啊，这个我们要记清楚啊。&lt;/p&gt;
&lt;p&gt;那大家说一下什么不是命题呢？什么情况下才不是命题？我们看一下非命题的例子啊——午饭吃啥&lt;/p&gt;
&lt;p&gt;这个很明显，这是个疑问句，他不是个陈述句是吧，它在提问，而不是描述一个东西，一个事实。它没有真假可言，你说午饭吃什么，这哪还真的还是假的，你说这个没有逻辑对吧。所以你不能回答午饭吃什么，这句话是真的，你也不能这样回答。所以它压根就不是命题，它就是个疑问句。&lt;/p&gt;
&lt;p&gt;比如说再看一例子——x - 4 = 6&lt;/p&gt;
&lt;p&gt;来我问你这是啥？这是一个包含变量，我们叫做open sentence。我们中文里边有一个叫做开路句。&lt;/p&gt;
&lt;p&gt;什么叫开路句？这个真假取决于x变量的值。 包含一个变量&lt;/p&gt;
&lt;p&gt;when x = 10 t&lt;/p&gt;
&lt;p&gt;when x = 	  f&lt;/p&gt;
&lt;p&gt;如果x为10那这个肯定是true，那如果x是其他的，那基本上是false。所以它没有一个固定的明确的真值，因此它本身就不是一个命题。它包含了一个变量。&lt;/p&gt;
&lt;p&gt;所以开路句也就意味着包含一个变量，而陈述要求我们要有一个确定的事实，所以它本身不是一个命题。这是我们要给大家讲的，所以大家知道命题这个概念啊，很重要。&lt;/p&gt;
&lt;p&gt;所以为了我们方便研究操作逻辑我们通常会使用变量。&lt;/p&gt;
&lt;p&gt;例如，设p命题为：天在下雨&lt;/p&gt;
&lt;p&gt;当我们要讨论天在下雨这个命题的逻辑关系时，我们就可以用P来指代它。&lt;/p&gt;
&lt;p&gt;好，那我们接下来就要去给大家介绍逻辑运算符（Logical Operat）。逻辑运算符呢我们在C语言，我们在其他语言里基本上都有一个。&lt;/p&gt;
&lt;p&gt;有人说：我学了离散数学太爽了。两门课，计算机里边最难的两门。我认为计算机特别是软件工程，计算机科学里边两门最难的课：一门是data structure就是数据结构和算法，一门呢就是我们的离散数学。这是公认的，通用的比较难的课。这两门课只要你学的很牛逼，那很爽的啊，那基本上很爽。所以我们必须要理解逻辑运算符，我们在整个离散数学当中要解释所谓的逻辑运算符，怎么去理解。&lt;/p&gt;
&lt;p&gt;我们刚刚有了命题，所以下一步讲就是把这些东西，简单的命题组合起来，形成更复杂的复合命题，刚才我们学了命题是吧，我们接下来可能要组合起来变成复合命题。那么就需要用到逻辑运算符。&lt;/p&gt;
&lt;h2 id=&#34;复合命题&#34;&gt;复合命题
&lt;/h2&gt;&lt;p&gt;1.否定（Negation， ¬）&lt;/p&gt;
&lt;p&gt;¬P 读：Not P 非P&lt;/p&gt;
&lt;p&gt;它的作用很简单，把原先命题的真值给颠倒过来&lt;/p&gt;
&lt;p&gt;if p true, ¬ P false&lt;/p&gt;
&lt;p&gt;if p false, ¬ p true&lt;/p&gt;
&lt;p&gt;设P 天在下雨&lt;/p&gt;
&lt;p&gt;¬P 天没在下雨&lt;/p&gt;
&lt;p&gt;¬p 先下雨是假的&lt;/p&gt;
&lt;p&gt;Truth Table 真值表&lt;/p&gt;
&lt;p&gt;P	¬P&lt;/p&gt;
&lt;p&gt;T	  F&lt;/p&gt;
&lt;p&gt;F	  T&lt;/p&gt;
&lt;p&gt;比如说天没在下雨，然后你一开窗户一看，简直是胡说八道，外面正下着哗哗大雨。你这个是假的，颠倒过来就是true。&lt;/p&gt;
&lt;p&gt;2.合取（Conjunction, ∧）&lt;/p&gt;
&lt;p&gt;简单来说就是and。&lt;/p&gt;
&lt;p&gt;命题p 和 q的合取记作 p ∧ q&lt;/p&gt;
&lt;p&gt;当p和q两者都为真，p∧q才为真。&lt;/p&gt;
&lt;p&gt;p 天在下雨&lt;/p&gt;
&lt;p&gt;q 我湿了&lt;/p&gt;
&lt;p&gt;p ∧ q : 天在下雨并且我湿了&lt;/p&gt;
&lt;p&gt;p	q		p∧q&lt;/p&gt;
&lt;p&gt;T	T		T&lt;/p&gt;
&lt;p&gt;T	F		F&lt;/p&gt;
&lt;p&gt;F	T		F&lt;/p&gt;
&lt;p&gt;F	F		F&lt;/p&gt;
&lt;p&gt;3.析取（Disjunction， ∨）&lt;/p&gt;
&lt;p&gt;or ||&lt;/p&gt;
&lt;p&gt;p &lt;strong&gt;∨&lt;/strong&gt; q&lt;/p&gt;
&lt;p&gt;当p或q中至少有一个为真，那么p ∨ q = true，那么特别这里要提醒一下，&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【数学】离散数学-0</title>
        <link>https://airmuamua.github.io/hugoweb/p/b021/</link>
        <pubDate>Sun, 07 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b021/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b021/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%82%8D%E6%99%9A%E8%B7%AF%E7%81%AF-%E5%B1%B1%E8%84%89-%E6%B0%B4%E9%9D%A2.png" alt="Featured image of post 【数学】离散数学-0" /&gt;&lt;h1 id=&#34;离散数学与软件工程000离散数学简介&#34;&gt;【离散数学与软件工程】000.离散数学简介
&lt;/h1&gt;&lt;h2 id=&#34;离散数学简介&#34;&gt;离散数学简介
&lt;/h2&gt;&lt;p&gt;在正式进入我们第一的学习之前我跟大家先聊几分钟，为什么我们要坐在这里学这门如此抽象的课程。&lt;/p&gt;
&lt;p&gt;那么第一印象是大家从中学到大学最多接触的就是微积分了，微积分处理的是连续的事件，平滑的曲线，有序的变化，流动的时空。你可以把它想象成一个平滑的斜坡，相当于就是停留在斜坡上的任意一个点，因为它是一个平滑的曲线，任意一个点都有可能。&lt;/p&gt;
&lt;p&gt;但离散数学不是这样，顾名思义，他的研究就是离散的、可数的对象。世界不是一条斜坡，而是一个很清晰的一个台阶。就跟你爬山一样，每一个台阶都非常清松。你只能站在第一级、第二级、第三级的台阶上，绝不能站在1.5的台阶，没有这样东西。&lt;/p&gt;
&lt;p&gt;对于离散数据来说，整数逻辑命题计算机当中的零和一（称之为叫比特），那么社交网络当中的人际关系图，这些都是离散数学研究的对象。&lt;/p&gt;
&lt;p&gt;简单来说，如果微积分是一门描述或者说叫模拟世界的语言，那么离散数学就是数字世界的语言，那么对于这个AI充斥的时代，离散数学就是你制胜的法宝，特别是对计算机的同学来说。&lt;/p&gt;
&lt;p&gt;所以数学终究是一门描述性的语言。&lt;/p&gt;
&lt;h2 id=&#34;那么这个课到底有什么用啊&#34;&gt;那么这个课到底有什么用啊？
&lt;/h2&gt;&lt;p&gt;他几乎我可以告诉你，是你未来专业生涯的内功心法。&lt;/p&gt;
&lt;p&gt;我们知道在座的很多同学，我们的目标可能会成为一名优秀的软件工程师、数据科学家、算法专家、网络安全专家，为你们会学到各种各样的编程语言，五花八门，比如说pthon，Java, C++，C啊等等。你们会学习各种各样的框架技术。这些就是相当于你们手中的武器，但是一个高手不能只有锋利的兵器，需要深厚的内功，而离散数学就是你们在计算机领域当中的内功。
每次你打开高德地图、谷歌地图他能在毫秒之间为你规划一条最短的路径，那这个背后呢我们称之为叫做图论。图论的算法这是离散数学的一个核心。
比如说你电脑CPU之所以能计算他是因为有亿万个微小的逻辑门电路组成，这些电路的原理就是我们要学习的逻辑。
你每发送一条微信，每一次网上银行的转账之所以是安全的，是因为有数论和密码学在背后保护，这也是离散数学当中的一部分。
从人工智能到数据库的设计，从算法分析到操作系统，你未来要学习的几乎每一门的专业课，核心的课它的基石全部都深植于离散数学。
没有这门课程打下的基础，你或许能成为一个熟练的码农。在一个AI的时代，你确确实实能用AI写API，但很难能够成为一个解决问题或解决复杂问题的计算机科学家，甚至是顶尖的工程师。这就是你和现代人，和现在在AI时代和其他成员拉开差距的一门课。&lt;/p&gt;
&lt;h2 id=&#34;那我们为什么要用通俗的语言去学习它呢&#34;&gt;那我们为什么要用通俗的语言去学习它呢？
&lt;/h2&gt;&lt;p&gt;现在我想谈一个现实的问题，就是我们过去的学习当中呢，无论是中学还是大学基础课程，我们更常常习惯关注于&lt;strong&gt;怎么算&lt;/strong&gt;，或者说如何利用公式啊，如何利用大量的刷题，特别是中国的学生。就是刷题，利用题海战术获得一个确切的答案。那这种训练呢，似乎在高考这个领域是非常有效的，但在实际应用领域里狗屁不是。但是这也可能就是说，我们思维上就造成了一处短板。特别是在中国的学生里，他思维上是没有任何思维的，他没有逻辑，我们很少被系统的去训练。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要这么做？他是怎么来的？这个方法为什么是正确的？他是如何被证明的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些东西也是中国的学生唯一欠缺的东西。&lt;/p&gt;
&lt;p&gt;所以这门课，尤其是像我们即将要开始的逻辑和证明这一章，我们就是要攻击这个面板，大学教授还有中学的教师你们听好了，我向你们发出挑战，我向你们发出致命的挑战，还有教育制度向你们发出这样的挑战。&lt;/p&gt;
&lt;p&gt;因为我们要做的训练不是你的计算能力，如果你中学的时候你计算能力很垃圾，你说我微积分我都不知道是啥，求导我也不知道是啥，在我们这门课里你根本就无所畏惧。&lt;/p&gt;
&lt;p&gt;我们这门课专注的不是你的计算能力，不是比的谁算得快。谁算的快那计算机比我们算的都快，拿计算机咔咔咔比我们算的都快。我们这节课要讲的是你&lt;strong&gt;抽象的思维能力&lt;/strong&gt;，&lt;strong&gt;逻辑的推理能力&lt;/strong&gt;以及&lt;strong&gt;严谨的证明能力&lt;/strong&gt;才是我们这节课真正的重点。这门课对于一些专科背景或者是基础稍弱的同学来说，可能是一次全新的甚至是有一些有意思的挑战。你可能会觉得他很绕，不像解方程那样，不像有公式那样套着去用，不用担心这很正常。&lt;/p&gt;
&lt;p&gt;因为我们正在重塑我们整个思维的习惯，所以我的任务就是把看似这些抽象的概念，用最通俗的语言，用最贴近我们生活的例子把它讲明白。我们会一步一个脚印，确保每个人都能跟上。而且呢最重要的是，我们尽可能不是用国内的教材我们不使用那些很抽象的，就是看起来只有北大清华的人才能听懂的那些课程，我们不采用那个。其他的课跟我们的课是完全冲突的，我们就相当于是对整个教育行业，中国的教育行业发起了一次总攻。&lt;/p&gt;
&lt;p&gt;所以我们的目标呢不是让你去背符号，也不是让你去背定义，对于文科的学生来说呢这也是一个福音，而是让你掌握一种真正的我们叫做计算的思维，一种能够&lt;strong&gt;清晰的严谨的分析问题，设计方案，证明正确的思维方式&lt;/strong&gt;。这种思维方式无论未来技术如何去更迭，无论未来你处在什么样的岗位上，我相信你都是你人生当中最宝贵的财富。&lt;/p&gt;
&lt;p&gt;好了，说了这么多，相信大家已经对这门课有一个初步的认识，那么我们开始构建这座计算机科学大厦的第一块基石，就是逻辑。我们下节课再见。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【C/C&#43;&#43;】C语言「第五章」</title>
        <link>https://airmuamua.github.io/hugoweb/p/b017/</link>
        <pubDate>Thu, 14 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b017/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b017/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91JavaScript-%E4%BB%A3%E7%A0%81.png" alt="Featured image of post 【C/C&#43;&#43;】C语言「第五章」" /&gt;&lt;h1 id=&#34;第五章&#34;&gt;第五章
&lt;/h1&gt;&lt;h2 id=&#34;循环在生活上的作用&#34;&gt;循环在生活上的作用
&lt;/h2&gt;&lt;p&gt;这一章主要的内容就是研究透彻循环。那程序这个设计逻辑，这个循环呢，也是非常有意思的一个环节。很多人觉得他没意思，没意思是因为你学校教的不好。循环这个东西，我跟你讲，他就有点像咱们这个操场上去跑步。那在操场这个开头呢其实也是个结尾，对吧。那假如说我要跑十圈，那你说你说你作为一个人来说，你怎么去跑。从跑道上，任意一个位置作为起点开始，跑第一圈，作为一个计次。那再跑一圈，是不是记两次，什么时候会结束，第十圈。所以一个循环按照逻辑来说有什么？&lt;/p&gt;
&lt;p&gt;一、它有一个&lt;strong&gt;开始&lt;/strong&gt;，二、还有一个计数。那不然没有计数，我操，假如说你这里跑第一圈啊，老师罚你跑步跑第一圈。跑第一圈之后，老师说我没看见，你跑到第二圈，老师说我还没看见，你再跑，那你这肯定就不玩了。那你这不是找事么。&lt;/p&gt;
&lt;p&gt;所以循环一定要计数的，必须得保证能够计数。不能计数，我没有办法去判断他是不是已经跑了多少圈，也没办法达到目的，对不对。我到底跑了几圈，我没有目的，我也没有计算数据。所以呢，循环要有一个开始，要有一个计数。&lt;/p&gt;
&lt;p&gt;第三个就是什么时候跳出循环，说白了就是&lt;strong&gt;结束&lt;/strong&gt;。那么在结束之前呢，大家想一想。&lt;strong&gt;开始、计数、结束&lt;/strong&gt;，我这整个这么样一个东西它是不是相当于就是一个循环系统。它就是一个循环嘛。&lt;/p&gt;
&lt;p&gt;你假如说我就操场跑10圈，那么开始我刚才跟大家讲了。要有一个起点，对不对。从哪个地方开始？从这个地方开始，它必须要有一个开始。第二个它必须要有一个计数，第三个它必须要有一个结束。结束就是跑10圈啊，我跑10圈就可以结束了。那么这个循环的内容是什么呢，循环的内容就是跑步。&lt;/p&gt;
&lt;p&gt;所以从这个角度来说的话，这三个是在为谁服务的？为循环的内容。就是我循环的目的，我要去做到，我循环到底为了什么，我为了跑10圈，对不对。它有一个内容，九圈七圈它是一个内容，就是我到底要循环什么？我循环去跑步没错吧？这个逻辑循环去跑，这里就是循环的内容，这个很重要啊，这个只要这点懂了，这一章基本就结束了。&lt;/p&gt;
&lt;p&gt;那么程序设计为什么要有循环呢？显而易见的啊。你比如说我们要打印数字，那么从1~100。那我们难道要写100个printf()吗，可能吗？&lt;/p&gt;
&lt;p&gt;所以从理论上来说，循环的作用，一、&lt;strong&gt;避免重复，提高效率&lt;/strong&gt;。第二种是什么呢，如果我们要&lt;strong&gt;处理大批量的数据&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;比如说记录一些用户输入了什么东西，你按下键盘你滚动键盘你QWER4个键一起按，技能一起按，我得记录一下你按了什么技能啊。这个记录是不是我记录一个键，记录两个键，记录3个键，记住4个键，我记录100个键，记录1万个键，记录你按下的每一个键。被记录进去，他是不是也需要一个循环。不停的要去记录，你去到底输入了什么东西，包括我们在记事本上去打字，那么同样的，它也是一个循环，我们要不停的去记录。所以我们在打字的时候，其实实际上它也是一个循环程序。&lt;/p&gt;
&lt;p&gt;第二个，循环的作用。&lt;strong&gt;处理大量内容&lt;/strong&gt;。刚才我们说了，跑十圈其实是一个大量的内容。跑100圈，跑1万圈，它都是一个大量的内容，循环就可以处理大量的内容。&lt;/p&gt;
&lt;p&gt;第三个。循环它的特点是什么？它根据条件的不同执行不同的次数。不同记次。说白了就是我要求他条件不一样。&lt;/p&gt;
&lt;p&gt;你比如说我去饭店里面去点饭，点菜。根据客人的需求呢，厨师可以决定炒多少盘菜，每盘菜炒多久。&lt;/p&gt;
&lt;p&gt;所以他就有一个什么呢，&lt;strong&gt;灵活控制行为&lt;/strong&gt;。灵活控制程序的行为，第三步它有点像if了，有点有点这种感觉了。只不过这个衣服if一直在去判断他能不能去。&lt;/p&gt;
&lt;p&gt;你比如说客户要求。每一盘菜都要炒10分钟，第一盘菜炒10分钟，第二盘菜炒10分钟，第三盘再炒10分钟。它是有一定的控制的，对吧。那么下一个客户来的时候呢，他要求变了20分钟，哎，有这个感觉。&lt;/p&gt;
&lt;p&gt;所以我们要知道程序设计为什么要有循环这三大点啊，一个是&lt;strong&gt;避免代码重复&lt;/strong&gt;，第二个是&lt;strong&gt;处理大量数据&lt;/strong&gt;，第三个是可以&lt;strong&gt;控制灵活的行为&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;循环的三个作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行重复的任务&lt;/li&gt;
&lt;li&gt;检查机制&lt;/li&gt;
&lt;li&gt;简化代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们现在已经知道，对于我们在程序当中的循环，实际上他应该会有一个过程。这个过程是在生活上去理解循环有一个步骤。那么在程序当中他的理解是这样的，它有这样一个过程，这个过程相当重要。&lt;/p&gt;
&lt;h2 id=&#34;循环开始之前的意识问题&#34;&gt;循环开始之前的意识问题
&lt;/h2&gt;&lt;p&gt;遇到循环大家不要害怕啊，就是说我会带着大家去训练啊，除了我们课堂上所讲的这些内容，我们这个循环当中的每一个案例。我希望大家每一个程序能上手个10遍啊，20遍其实都不过分啊，主要是我们在训练。哪怕你每一个训练休息个10分钟。一定一定要这样做，一定一定要记下来啊，就是说，笔画一画，在纸和笔本子上画一画，注释写一写，逻辑写一写，一定要确保训练当中的每一个内容你都能够完全的掌握。不是把代码背下来，而是你完全的能够掌握，而是你完全的能够凭借一个东西，你就马上能写，就是能想出来，能写出来一个程序。差不多在20分钟之内，半小时之内，你能写的差不多，甚至更快都有可能。我觉得这样就OK，如果不够的话，你就限制时间，让自己去训练一下，理解，训练，这是本章节最重要的内容，一定确保要理解while循环for循环的各种各样的内容。&lt;/p&gt;
&lt;p&gt;好就是这样啊，我希望大家能够做足充分的准备训练啊，千万要记得，不是只理解了就完事了啊。这一章的内容就是这样，就是一定要充足训练。当然，以后的也是这样，一定要充足的训练才能确保你掌握这样的内容。这确实是啊，那就这样好吧。那我也希望就是你学到这个章节，如果你跟学校是同步的话，那你也可以去做一做网上的一些练习，可能有一些练习比较难啊。觉得你没学到那就无所谓，就是你觉得跟循环有关系的练习啊。可以找一找，可以看一看，练习一下，说不定会有提高啊。但是你说你学校的那些选择题目其实无非就是语法上刁难你对吧，什么i++i&amp;ndash;的对吧，无非就是这些东西刁难你对吧，其实实际上它就是语法上挖坑这个对吧。这个是有的啊，这种坑一般都是新手容易犯错误，逻辑上不严谨啊。这个也是需要训练啊，慢慢去摸索这个路肯定就铺的很快。但是有的学校一上来就到到这章就开始讲数学讲算法，这个我觉得有一点不太妥。除非你要把这个事情讲的很清楚，为什么要有这个东西。不然的话，别人就以为纯粹的coding就是数学啊，那这个就没意思了，纯粹的coding就是算那就没有意思。因为coding不只是算法的数学，数学和算法只是起到一个其中的作用而已，仅仅一个小作用。我们在后面的部分，大家可以轻松的体会到我的教学跟别人不一样的感觉，我将变成艺术。&lt;/p&gt;
&lt;p&gt;当然了，有的数学知识可能我会稍微强调一下。不会太有，几乎都是带着大家去分析逻辑，一步一步的推敲。为什么要加1，为什么要减1，像这样一步一步去推敲。这个我也是有感触，因为像中国大陆的数学的教育，应试教育特别厉害啊。那这个这个风格这个style都带到Computer science领域内了，我觉得这个是不应该的。因为你像在北美教数学，大家注重的是推理，这个很重要。就是教授一定会教你推理，到底是怎么来的，这个东西有什么用处，一定会告诉你。如果他没有告诉你，可以直接去问他，课堂上直接就打断他，这是不一样，对吧。这个环境咱就不多说了，反正就是这个样子。&lt;/p&gt;
&lt;p&gt;我们能做的就是，知识呈现给你，那命给掌握在你的手里。&lt;/p&gt;
&lt;h2 id=&#34;初探while循环&#34;&gt;初探while循环
&lt;/h2&gt;&lt;p&gt;我们这里简单的介绍第一个循环，while的使用方法。那么while非常简单，你比如比如说我现在我要去跑步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b017/jwh1.png&#34;
	width=&#34;1919&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b017/jwh1_hu_6773428ad29357e7.png 480w, https://airmuamua.github.io/hugoweb/p/b017/jwh1_hu_4d1282c984e58937.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;跑圈案例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;总结，循环第一步要初始化数据。什么叫初始化呢？首先，第一，我要循环，什么时候会结束？它的目的，它的目标是什么。我们的总圈数是不是10，这就是它结束的一个目标。我们叫结束的目标。还有一个是什么？初始化跑的数据有初始条件。我们从零开始，这就叫初始条件。对吧，这就相当于你打怪升级一样，你第一次就有一级嘛，对不对，我打到100级，那初始的等级就是100级，刚出新手村肯定一级对不对。这10就相当于你要打那个目标。这也类似于厨师做菜之前要准备好所有的食材和调料。初始化，然后就会有一个循环的条件判断。这个条件判断的是什么？什么时候执行，什么时候才会一直跑。一个厨师如果做菜的时候菜没熟，他是不是要一直炒一直炒一直炒。那这一步就相当于判断什么，判断他什么时候，最后这个条件。注意它跟if一样，这个条件为true的时候，他才会去执行代码，叫做执行循环体。也就是说，这个条件只要为true，就必须执行循环体。所以当我们跑的圈数不够的时候，我们就要继续一直跑。你跑的不够啊，你要继续跑。你这个菜没做熟，你要继续炒。那么while里边这个条件就是这样的，当这个条件为true的时候，它就会触发循环。除非什么时候结束，除非这个条件为false。除非while这里边的条件为false的时候，我们才不会去继续跑下去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;条件判断&lt;/li&gt;
&lt;li&gt;循环体&lt;/li&gt;
&lt;li&gt;迭代&lt;/li&gt;
&lt;li&gt;终止条件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这五个东西相当重要，如果没有这五个东西，就构不成一个循环体。只要少了一个，就构不成一个正常的循环。&lt;/p&gt;
&lt;h2 id=&#34;自动贩卖机案例&#34;&gt;★自动贩卖机案例
&lt;/h2&gt;</description>
        </item>
        <item>
        <title>【C/C&#43;&#43;】C语言「第四章」</title>
        <link>https://airmuamua.github.io/hugoweb/p/b016/</link>
        <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b016/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b016/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BB%A3%E7%A0%81-%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89-%E7%94%B5%E8%84%91.png" alt="Featured image of post 【C/C&#43;&#43;】C语言「第四章」" /&gt;&lt;h1 id=&#34;第四章-分支和跳转&#34;&gt;第四章-分支和跳转
&lt;/h1&gt;&lt;p&gt;我们这一章呢来讲解C语言控制语句当中的&lt;strong&gt;分支和跳转&lt;/strong&gt;。这个内容相当的重要，也就是说我们前几章的内容只是简单的去概述了C语言当中会经常用到的一些细碎的东西。比如说像变量、输出或者是一些运算符各种各样的符号这种简单的东西。&lt;/p&gt;
&lt;h2 id=&#34;选修决策控制&#34;&gt;（选修）决策控制
&lt;/h2&gt;&lt;p&gt;那么我们从现在开始学习的内容就偏向于稍微实用一些，你比如说我们早上，就比如说起床。你说如果今天外面天气晴朗，那么骑自行车去上班。那么如果天气没有晴朗呢，你比如说如果下雨，那我们怎么办？选公交呗。那么我们会发现它其中有两个最重要的一点叫什么，叫做（如果……选……，如果……选……），这个很重要。它就相当于有一个东西存在了，如果这个条件是对的，那么就怎么怎么样，他是有这样一个逻辑的存在。&lt;/p&gt;
&lt;p&gt;所以说人怎么样，人是有决策能力的。而我们今天所说的C语言当中的&lt;strong&gt;逻辑的判断&lt;/strong&gt;就是可以让程序去决策，让程序去选择决策，因为我们通常人脑去想的时候今天如果天气晴的时候我就自行车，如果下雨了就公交车，是我们人脑去想。但是如果我们想要程序去做决策的话我们就要考虑这一点，我们就要考虑好多好多种可能。&lt;/p&gt;
&lt;p&gt;所以我们希望让程序去做决策它的前提是什么，它必须要做判断，它判断这个东西是不是为true能理解吗。如果说像我刚才讲的那样，如果让你写程序，如果程序去判断天气，如果天气是晴，那么自行车。不然的话，就是下雨嘛，就是公交车。它有这么个感觉。&lt;/p&gt;
&lt;p&gt;说白了程序要去控制你们经常用到手机上天气预报对不对，手机上天气预报可以获得天气。那么一个程序如果可以获得天气它很有可能会做很多很多的事情。你比方说我举个例子，假如我们现在开发一个天气的应用程序。我现在就是如果温度是大于30℃的，那么这个情况我就要提醒用户高温。然后给你个弹框，给你个感叹号，说你要小心今天可能有高温或者是你要多喝水。那么如果说我们做这个软件它的温度它要小于-30℃，那么这个时候我们也会给一个警告，寒冷警告。一弹框告诉你今天最好不要出门。它是有一个条件去存在的。我们人类是怎么去判断条件的其实是显而易见的，我们瞅一眼就知道了对吧，根据我们的认知或者说知识来去判断。那么C语言程序它怎么去判断的，程序是如何去判断一样东西的条件。哎，我们之前说过布尔类型当中有一个true或者是false。表达式的值，大家还记得吗。如果为ture的话就表达它的条件是通过的，如果为false的话它的条件就是不通过的，就是错的或否。所以就想刚才我们说的那样，我们之前学那个？ ：这个东西的时候我们当时讲的很清楚。&lt;/p&gt;
&lt;p&gt;那么为什么编程语言最初设计的时候要有他呢，因为我们现实世界总是充满无尽的条件和选择。&lt;/p&gt;
&lt;p&gt;有人说，哎如果为去大学要不要找对象呢，如果为找了对象肯定会影响成绩，那如果不找对象呢，我性饥渴。哎我没事我总是找点玩具或者是……，啊，是吧。不太舒服不太爽，就想找个对象。找个对象呢，哎这个饥渴大家都懂，年轻人对不对，火气旺啊是吧。女生也是啊，女生这个也很饥渴难耐。但是呢它就想如果我去找了一个对象，可能会影响成绩，我天天去约会了啊，天天去开房了，就觉得学习的时间变少了。但是有些人不是这样的，有些人谈了对象之后成绩反而变好了，有这种情况，也是有的。他俩一起在图书馆去学习，他这种也有，挺有意思的是吧。所以有些人觉得，如果为谈了对象，我就怎么这么样，是不是。这个世界充满了各种各样的条件和选择这是很正常的。你比如说你谈恋爱，你说毕了业了我们一起去哪呢，对不对。这时候就想了，如果我要去大城市，我在想能不能留下来，留在那个城市对不对。哎一想，如果为回到家乡好像也没有就业单位。总是充满了条件和选择。&lt;/p&gt;
&lt;p&gt;所以编程语言最初的设计，第一个，要反映现实世界的复杂性。这个复杂性指的是什么，指的就是条件和选择。或者说更严谨一点叫做决策。&lt;/p&gt;
&lt;p&gt;就是编程语言如果没有处理条件和选择的机制它就没有办法去解决现实生活当中的问题，对不对。它只能去算数，只能去按照我们想要的东西去算数，我们之前学了那么多运算符，它只能去算数那这样的意义在哪呢。没有意义，是不是。之所以程序是软件的一部分，说白了就是你要走的一个流程。所以这里呢我要提醒大家，现实生活当中也是如此。它一定会有一个判断，这个判断如果不满足我就要去找其他的判断，能理解吗。&lt;/p&gt;
&lt;p&gt;就跟你谈对象一样是吧，给你相亲了一个对象，你总得满足点人家啥是吧。满足的这个条件是什么，哎，房，哎，车，哎，工资。那么可能还有其他的条件，每个人的条件不一样。类似的它就会有一个条件，这个条件是一定要满足的。如果不满足，请你滚蛋，不好意思，pass，下一个，它就会有这样一个逻辑。那么编程语言其实也是如此，它应该要有这个东西。&lt;/p&gt;
&lt;p&gt;第二个就是什么，灵活性。要根据不同的情况来做不同的决策和响应。那如果说大家一出生就给你安排好了什么所谓的东西，那显然是有问题的。哎，应该要根据每个人不同的情况随机的、灵活的去处理这些东西。这是软件当中非常重要的一个观念，灵活性和适应性。&lt;/p&gt;
&lt;p&gt;再给大家讲个例子，红绿灯。如果红灯亮起，大家都会停下。如果绿灯亮起，大家都会过了。它也是一个判断了。大家想这个红绿灯里面的这个东西它是不是也是一个程序。他其实是一个程序，他需要写的，不然的话它怎么去控制红绿灯的机制呢。所以这很有意思啊，就是说我们生活当中处处都有程序当中的判断，你看像医院挂号也是一样的，你必须要满足这个要求。你不付钱，你挂号你没有付钱，假如说你所有的付款方式都试了，你都付不了钱，那你就不可能看病了。你只有满足这个条件，你可以换，但是你必须得满足条件，满足付款的条件你才可以去看病。那么程序当中肯定是要有的，不然的话那医院的挂号系统它如果不是软件去做判断的话那恐怕已经显而易见的事情了。所以选择决策这些东西在程序当中相当重要，而最重要的就是我们要搞清楚这是什么，背后的逻辑这个相当重要。&lt;/p&gt;
&lt;p&gt;如果程序的逻辑设计的有问题，那么它就没有办法去考虑多数的问题，去考虑到多种可能。它不可能去考虑到全面的问题，我告诉你任何一个程序和软件都不可能全面的去考虑如果的可能，全面这个东西是不存在的，没有这样的东西。但凡只要有地方告诉你是全面的或全面实现如果的可能它就是在骗你。就是有一个电影叫《黑客帝国》，有一个非常著名的名言：若有完美，定是谎言。这是肯定的啊，没有完美的东西。所以我们程序设计当中也难免会考虑到不全面的东西，这是很正常的。所以就有人工客服的原因了对不对。你们用的那些就是AI小助手，或者是人工智障就是智能客服。你们经常会用到各种各样的公司的产品会有各种各样的智能客服，包括淘宝啊，京东这种都有智能客服。如果智能客服当中它列举给你的这些你都解决不了你是不是要找人工。因为它的所有如果都不满足你的条件，这个意思。&lt;/p&gt;
&lt;p&gt;所以你会发现在生活当中处处都会有控制流程，（如果……那么……）这样一个流程。它的条件是相当重要的。所以我们人生当中的条件，决策，如果，那么为谁服务，逻辑。它要有这么个感觉。如果你知道有这么个感觉并且你已经能确认现实生活当中已经有了这些东西，我觉得就OK了。&lt;/p&gt;
&lt;h2 id=&#34;if与if-else&#34;&gt;if与if else
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif1_hu_54c0d61f8395f628.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif1_hu_6060bfdc8feef114.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;当number大于10，执行if内的语句&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果说if内只有一条语句，那这个时候可以把大括号省略，语法上是可以通过的。但是我不建议大家去这么做，可读性非常差。所以考试的题目才会非常变态，没意思啊。就会问你不带花括号带花括号然后输出啥这种。实际上在公司里边基本上来说还是把花括号带上，因为这样很清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif2_hu_39d8a4bf192b633d.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif2_hu_9bcb1478217b1b1d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;if条件为假，执行else内的内容&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;同样else内只有一条语句时，可以省略掉花括号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif3.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif3_hu_94080e459d900780.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif3_hu_c17148a281d13bf3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;那如果你不带花括号这种情况怎么办&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;因为我说了，因为你不带花括号只能代表这一行，这个nnnnnn。也就是说不管条件是什么，它都会输出。只认可一行，其他的它不认可。它看起来像独立的。&lt;/p&gt;
&lt;p&gt;这个考试呢，国内的考试经常会考这种东西，就是问你带不带括号会影什么东西。我跟大家去讲，实际的程序员不会这样去写，很少。除非下没没有代码会这样写。如果下面有代码的话一定要带花括号。记得我说的啊，除非下面没有代码，不然的话花括号老老实实带上。那这样的话很显而易见了对吧，如果number大于10那么这个数大于10，如果小于等于10的话直接就否则了。&lt;/p&gt;
&lt;h2 id=&#34;if嵌套-超市会员优惠简单判断&#34;&gt;if嵌套-超市会员优惠简单判断
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// 在线购物平台的优惠卷系统
// 根据用户的购物车总额和会员等级，系统提供不同等级的折扣。

// 1.如果用户是VIP 购物总额超过100，通过20%折扣
// 2.如果用户不是VIP，但购物车总额超过50，提供10%折扣
// 3.如果用户购物车总额不超过50，没有折扣
// 特殊情况，如果用户VIP，但购物车总额不超过100，也提供5%折扣
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif4.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif4_hu_36fc23b7467bcf48.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif4_hu_3a5f2d55a3ebe289.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;超市会员优惠简单判断&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;为何要避免嵌套&#34;&gt;为何要避免嵌套
&lt;/h2&gt;&lt;p&gt;判断的话，在企业当中有一些坑我需要大家去理解。你比如说刚才向我们展示的程序是相当经典的，我们可以在任何地方都可以用到它。我举一个例子。像这种情况它就忽略了一个问题，就是忽略了一个等于100的问题，你没有去处理等于100的问题。&lt;strong&gt;条件检查&lt;/strong&gt;，所有的条件检查应该包括尽可能的值，所以这里我们正确的写法应该怎么样。将&amp;gt; 100改为&amp;gt;= 100。同样的，&amp;gt; 50改为&amp;gt;= 50。这样是较为精确的。&lt;/p&gt;
&lt;p&gt;那么同样，第二个呢，我们这个程序这样去写，我跟大家讲。像这种实际在企业当中不常见。你们不要以为：啊，这么夸张，那我们考试的题目包括这些试卷是不是都不符合企业的标准。我可以放心的回答：是。因为它的变量名都不符合标准，都是ABCD。就是像这种嵌套的，我告诉你，实话实说，非常的难以阅读和维护。因为人很难从这些嵌套当中去寻找整个系统的设计的逻辑，是很难的。就是我们刚才为什么要学这么多的注释，就是要告诉你这种方式，如果没有注释的话，我真的不知道它在干什么。因为它的嵌套太多了。&lt;/p&gt;
&lt;p&gt;过多的嵌套层次会使得代码难以阅读和维护。所以从某种情况来说的话，一般1层if else就已经相当恶心了，就不要说两层了，不要说多层了。就是要是1层能去解决的事情我们尽可能不要去嵌套去解决，能理解吗。过多了是很难去维护的。&lt;/p&gt;
&lt;p&gt;你比方说今天老板又加了个要求，但是有一天你会发现你的要求越来越多你你不知道你在哪去写这个逻辑了，很有可能有一天这些逻辑都乱套了，要重新写，相当的恐怖。 那么同样的，我们还有一些代码要跟大家去讲，就是说更恶心的条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ((is_vip &amp;amp;&amp;amp; cart_total &amp;gt;= 100) || (!is_vip &amp;amp;&amp;amp; cart_total &amp;gt;= 50 &amp;amp;&amp;amp; cart_total &amp;lt;= 100)) {
	// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有的人它会这样去写，看起来很聪明，一层套一层。说白了就是如果是VIP的话并且total值大于100或者不是VIP的情况total值&amp;gt;50或者total值&amp;lt;=100，这是一个判断。像这种判断就比较复杂，人们很难去理解和维护，不知道你在做什么。当然你要是程序写习惯了你就知道它在做什么，因为它代码写的也不是太垃圾，因为它至少还有一些判断，它至少有括号嘛对不对。那这种就比较尴尬了，就是难以维护的，肯定是不好的，所以就应该避免这种情况出现。&lt;/p&gt;
&lt;p&gt;像这种写法呢也不是不行，但是从理论的角度来说，它不太容易去维护。这个代码这样去写虽然是OK的，但是我觉得不是太容易能够理解，这个代码还是有可以优化的空间，你比如说不用else if，因为else if条件一旦多起来就会非常的繁琐。我们就两个逻辑，要么是VIP要么不是VIP就可以了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif5.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif5_hu_14db8ac0b7878127.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif5_hu_ad6cfc297b08e39f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;像这样逻辑会比刚才那个else if要清晰的多&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果你在程序设计当中，如果你的else if特别多的话，然后又有一个else if这样的话就不太清晰，没有人知道你在写什么，非常的夸张，而且有些人它写这个东西它不带括号。考试的时候经常去去掉花括号去考你，这样是错的，因为else会跟他就近的一个if去匹配。&lt;/p&gt;
&lt;p&gt;所以这样的逻辑更复杂，我们在企业当中一定要避免这样的写法，避免考试中的任何一种写法，你考试的这些所有的代码其实都是不规范的。哪怕它是对的，哪怕它没有报错，都是不规范的，没有一个是规范的。就是因为像这种程序不会出现在企业里，不会的。如果你去工作了你要把代码写成这样，你会被开除的。哪怕你没有被开除别人也会骂你的。一定要把所有的括号都带上。大括号这个东西，能省，尽可不要去省它。能理解了吗。&lt;/p&gt;
&lt;p&gt;所以我们要知道啊，一旦这样去写的话我们就很清楚两块内容。我跟你讲，即便如此是这样，企业里也不应该这样去写。至于为什么，不是我们这节课的内容。只是告诉你有这种说法，你先有一个预防针。就告诉你不是它不是真真正正这样去写，那这样子光靠这种else if去套循环的话，那if else就套这种东西那恐怕就乱糟糟的了已经。你需要知道啊，它会有一些空间一些逻辑需要你自己去优化。你要知道这个就OK了，你要知道企业里可能不会用太多的if嵌套这种，很少的。&lt;/p&gt;
&lt;h2 id=&#34;选修入门提醒&#34;&gt;（选修）入门提醒
&lt;/h2&gt;&lt;p&gt;就是说如果说不是通过else去进行判断，那就是真正的去企业里写的时候，如果真的是这个案例可能会用什么。我跟大家讲，其实企业里用的啊，就如果稍微简单一点的那种，不是特别大的那种，简单来说就可以搞这个叫&lt;strong&gt;策略模式（Strategy Pattern）&lt;/strong&gt;。它就相当于是有不同的算法行为，那这个就是面向对象的知识，这个就不是C语言的一个范畴，它会涉及到很多，你比如像context上下文，strategy策略这种，它会有一些分离的算法。这样的话它就有不同的对象，就可以直接避免掉中间很多的if else的行为。就是面向对象的语言可以有这么一个特征去做这件事情，而C语言是不可以的，C语言是面向过程的语言。并不是说C语言low而是说C语言它并不适合做这种东西，如果可以要做的话，它就不用这个模式它可以用其它的。你比如说非得要用C语言的话我们也可以去做，比如说像使用后面会学到结构体，会定义一个策略接口，也是可以的。并不是说非得是面向对象语言是最好的，或者说符合我们的标准，不是这样的。更多的情况是取决于我们怎么去用它。&lt;/p&gt;
&lt;p&gt;那这个就不是我们这节课今天的重点了，这节课今天重点就是告诉你说，给你留一个预防针。就告诉你企业里边以后可能会用到它，这个情况是比较复杂的。我们没有办法去说一定会用到或一定不会用到它，我就可以告诉你企业里肯定不是这么简单去处理这个会员问题。以免到时候有的同学到企业里它真的给我这么写，然后说是我教的。我们做这个案例只是为了去演示else的用途但不代表说不重要。这个案例你还是要线下去多敲几遍，熟悉一下这套流程这个很重要。&lt;/p&gt;
&lt;p&gt;那么后面我们还会就是说举一个查表法，后面学到数组的时候还要跟大家去提一下查表法。那么还有一个就是说使用规则引擎，很多的这些大型的项目可能会有一些规则引擎，这就不是我们要考虑的了，还有一些复杂的事件处理可能会用到状态机，这就是以后在真正去到企业开发过程当中会逐渐的去了解到。所以现在不用慌，就告诉你有这么个解决方案。&lt;/p&gt;
&lt;p&gt;当然了还有一些现代的一些就是编程当中，一些高级语言当中可能会有一些叫做函数式编程，他也是会有一些可以处理这些内容，可以去避免这些复杂的结构，也是可以的，这只是从代码简单的层面去理解，所以我们这里就不多说，就是说你要知道有这么个东西。&lt;/p&gt;
&lt;p&gt;接下来就是说它不是说这个问题解决不了的，是可以解决的，而且我可以明确的告诉你，企业里为什么不用这么多的嵌套，他是有原因的，它不好去维护啊，不好维护的。一旦东西多起来，你比如说它现在它仅仅就是一个优惠的折扣，那如果说改天它会有一些其他的优惠折扣那应该怎么办。那你难道在这里要写无穷的if嵌套吗，那肯定是不合理的，那肯定是要有扩展，像这种扩展就比较难而且很多层次上来说它是不太靠谱的。&lt;/p&gt;
&lt;p&gt;所以大家要记得就是企业里真正去编写这样的VIP的这种客户行为，或者是这种嵌套其实是不允许的，我们这里就在跟大家多废话就是告诉你留个预防针以后你会知道的。现在不要去讲解现在给你们讲有点复杂了，不太好容易理解。你就先把这个if else的案例去敲，去熟悉if else的用法以及if else的嵌套，还有一个就是else if是不是可以优化掉。像这种都已经算是技巧了对于初学者来说，那至于后面的事情以后你们自然会知道。&lt;/p&gt;
&lt;h2 id=&#34;逻辑与或的短路行为&#34;&gt;逻辑与或的短路行为
&lt;/h2&gt;&lt;p&gt;我们这里再编写一个程序，多体会一下if的感觉，感觉和代码训练相当重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif6.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif6_hu_b093fce2e81db613.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif6_hu_966544c1d09eb2e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;我们看这个程序它妙在哪&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;妙在第一步判断，它必须同时满足的情况下才可以举行。它把同时满足的条件可执行的条件给抽离出来了，把逻辑放在了第一层，下面的是不可执行的这些判断。因为不可执行判断的东西太多了，可执行的东西少，所以它直接一条逻辑&amp;amp;&amp;amp;的这种行为把可执行少的东西给概括完了，这样的话我们有更多的操作空间去处理更多的不可处理的可能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif7.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif7_hu_5af57f6c2c57c831.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif7_hu_f6e8bb110b85c412.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;使用逻辑OR结束处理if-else的短路行为&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;所谓的这个&lt;strong&gt;短路行为&lt;/strong&gt;相当于可以理解为半路拦截的意思。&lt;/p&gt;
&lt;h2 id=&#34;ifelse与其他逻辑符的练习&#34;&gt;if&amp;hellip;else与其他逻辑符的练习
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/*
	玩家可以选择进入不同的房间，每一个房价都有不同的进入条件。
	房间A：玩家需要有VIP身份
	房间B：玩家需要至少有10个金币，或者是一个特殊道具
	房间C：玩家需要有VIP身份，并且金币数量不得少于20
	房间D：玩家需要有VIP或者特殊道具，并且金币数量不少于5
*/
// 玩家属性（在真是程序中可能来自用户输入或者是游戏逻辑）
bool is_vip = true;
uint32_t coins = 15;
bool has_speacil_item = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif8.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif8_hu_2c54a10e7a1ebb4.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif8_hu_b46d4321eb5148c8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;if…else与其他逻辑符的练习&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;访问权限的简单应用案例&#34;&gt;访问权限的简单应用案例
&lt;/h2&gt;&lt;p&gt;我们再写一个综合案例，这个综合案例呢应该要属经典，一个逻辑场景。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
	公司内部的权限问题。
	员工可以访问不同的系统资源，这取决于他们的职位和完成数量，权限规则如下

	1. 经理Manager 总是可以访问所有的资源
	2. 普通员工 Employee 如果完成5个以上的任务以后，则可以访问资源
	3.实习生 Intern 。。。。。。 10个以后，必须经过经理的批准才能访问
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif9.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif9_hu_8fab47c2cb78152b.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif9_hu_3ae4c13b7c615fea.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;访问权限的简单应用案例-1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么这个程序有没有优化空间呢，就是你看这里太多的else if()，如果这个条件越来越苛刻或者随时改动，那就很有可能会怎么样。就已经写好了，不需要在程序里再重复一遍，能理解吗。就这个规定完成几个任务，是不是需要得到经理的批准，这个东西它不是程序能负责的，它是人事部负责的，懂我意思吧。它应该就是提前挂在黑板上，让大家看到了，你完成几个任务你就可以去申请。那么这个程序，就是说它问题的关键是在于权限是否允许访问，而不是在于这个程序是否能够输出。所以这个程序可以根据需求去判断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif10.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif10_hu_ea7b7f49ec34b326.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif10_hu_4f62528650a7bcf1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;那这样的话就清楚了，一条变量语句就解决了&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么这个情况下，这个程序就有一些有趣。如果接下来，我添加了一些其他的身份，那么这个变量显然就不适合了。不过呢，异曲同工。就是说我们接下来学到数组的时候，我们可以把每一个批准的项放在数组里去检查，这样也是可以的，只不过在这里我们就不展示给大家看了。我们只需要存储每个人访问的权限，只要有一个通过的就允许他访问，这样也是OK的。所以在这种情况下去编写的时候，我们使用一个复合的逻辑表达式来确定他是否允许访问。我只需要拿到是否允许访问的东西就OK了。其他的不需要。&lt;/p&gt;
&lt;p&gt;但是我告诉大家，虽然这种方法减少了代码的复杂性，但是处理更复杂的逻辑的时候，这种方式就显然不好用，因为它的逻辑更复杂，反而会降低代码的可读性。只是告诉你有这种写法，就是说不是特别建议去写，如果要求非常低，已经没有可以优化的空间了，或者说叫做我们没有其他身份了，没有什么CEO啊CTO就这仨人了，你可以这样去写，因为这个逻辑是固定死的，不会再改了，几乎很少会改了。显而易见的，它不需要一层一层的去像else if那样去判断，它在变量赋值权限的时候，就已经提前做了判断，会减少一些逻辑，看起来会更好一点。但是我刚才跟大家讲了，这个逻辑稍微复杂一些，需要有注释才可以。而且企业当中肯定不是这三个，不一定是这三个，可能是其他的案例。就是像这种简单的访问已经固定死了，没有太多的逻辑，那么你就可以用这种方法。&lt;/p&gt;
&lt;h2 id=&#34;switchcase的用途&#34;&gt;switch&amp;hellip;case的用途
&lt;/h2&gt;&lt;p&gt;想象一下，如果刚才那种方法一直写下去，如果还有其他人参与进来的话，那我们写的这个逻辑显然就不太好，虽然这个if else看起来非常的清楚，但是这个可能会更复杂一些，我们该如何去避免这个问题呢，这就是我们这节课要学习的内容。&lt;/p&gt;
&lt;p&gt;switch这括号里面就和if一样，表示判断条件是否为真。case有点像电梯&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jsw1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jsw1_hu_f9664aae7319c752.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jsw1_hu_cd96b24d1230d7ce.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;这是用switch…case语句来去处理这样的逻辑&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是我们刚开始的时候我们默认一般会给false（bool access_allowed = false;）啊，这是肯定的对吧。所以我们在处理逻辑的时候才会给true。&lt;/p&gt;
&lt;h3 id=&#34;选修&#34;&gt;（选修）
&lt;/h3&gt;&lt;p&gt;那么在企业当中呢，我们肯定不能在这里面写条件，这个条件一般会把它放到外面去，那是我们后面学习的内容。就是说学到函数的时候，我们会把条件放到外面去。你比如我给大家举个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool check_access_for_manager();
bool check_access_for_emp(uint8_t completed_tasks);
bool check_access_for_intern(uint8_t completed_tasks, bool is_manager_approved);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​
​
​	int main(void) {
​	uint8_t role = 2;	//1=Manager; 2=Employee; 3=Intern
​
​	uint8_t completed_tasks = 6;
​
​	bool is_manager_approved = false;	//批准
​
​	//检查访问条件
​
​	bool access_allowed = false;
​&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (role) {
case 1:	// role == 1, manager
	access_allowed = check_access_for_manager();
	break;	// 跳出 到站了，我先下车
case 2:	//role == 2, Employee
	if (completed_tasks &amp;gt; 5) {	// 检查任务完成量是否大于5
		access_allowed = check_access_for_emp(completed_tasks);
	}
	break;
case 3:	// Intern
	if (completed_tasks &amp;gt; 10 &amp;amp;&amp;amp; is_manager_approved) {
		access_allowed = check_access_for_intern(completed_tasks, is_manager_approved);
	}
	break;
// ....
default:	// 默认情况下
	access_allowed = false;
	break;
}
if (access_allowed) {
	puts(&amp;quot;允许访问&amp;quot;);
}
else {
	puts(&amp;quot;拒绝访问&amp;quot;);
}
return 0;
}

bool check_access_for_manager() {
	return true;
}
bool check_access_for_emp(uint8_t completed_tasks) {
	return completed_tasks &amp;gt; 5;
}
bool check_access_for_intern(uint8_t completed_tasks, bool is_manager_approved) {
	return completed_tasks &amp;gt; 10 &amp;amp;&amp;amp; is_manager_approved; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你真正去写的时候他是这样的，是不是比刚才要好多了。啥也没有是吧。到最后就这样了，很简洁，然后其他的所有的处理方式都在下面挪过来了啊。到时候你们学到函数的时候，你们就知道它的精妙之处了。&lt;/p&gt;
&lt;h2 id=&#34;再探条件运算符&#34;&gt;再探条件运算符
&lt;/h2&gt;&lt;p&gt;我们这里还要再做一个运算符的联练习，就是说所谓的条件运算符，这个条件运算符也是可以表达判断的，当时我们只是简单的讲了一下，就是说？前面这个值如果是真就执行:前面假就后面。所以我们这里再写一个案例来去看一看，这个三元运算符到底在判断什么东西的时候会有效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/j%EF%BC%9F%EF%BC%9A1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/j%EF%BC%9F%EF%BC%9A1_hu_eaff16bff873f54f.png 480w, https://airmuamua.github.io/hugoweb/p/b016/j%EF%BC%9F%EF%BC%9A1_hu_22aab247014f1ca2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;计算机等级&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;检查账户锁定案例与提前return出&#34;&gt;检查账户锁定案例与提前return出
&lt;/h2&gt;&lt;p&gt;那么除此之外呢关于if-else的练习我们还有一个涉及到的一个问题，就是说布尔这个变量的直接使用问题，因为我们知道就是我们之前就讲过。假如说这里我写一个简单的系统吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif11.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif11_hu_25da5045e7023583.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif11_hu_18c563aea5f0d443.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;账户检查系统&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么我们做这个程序的目的是为什么，是检查。什么意思呢，就是说我们现在要模拟一个系统，密码如果输入错了三次就锁定，它要看这个账户是否被锁定了，能理解吧。如果输错了三次，那么直接就给他is_locked，就锁了。就说白了就是账户被锁定。&lt;/p&gt;
&lt;p&gt;我通过一个布尔值我可以这样去写，那么以后今后的程序里if会单独出现的状况很多，我们会单独给它一个判断。比如像这种，他是否输错了三次。现在是正常的。那如果说这个值，就假如说我输错了三次，那这种情况就账户被锁定了，不允许你再输了，能理解吗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif12.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif12_hu_3086873ce5d70891.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif12_hu_d4ec4be1dfed3c17.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;我们现在可以理解为return 0是退出&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;卫语句的使用租车案例&#34;&gt;卫语句的使用：租车案例
&lt;/h2&gt;&lt;p&gt;卫语句：先判断不好的条件&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif13.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jif13_hu_203aa35eaae1efb2.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jif13_hu_7b3e31e2015e0ca1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;租车案例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;简化逻辑表达式&#34;&gt;简化逻辑表达式
&lt;/h2&gt;&lt;p&gt;逻辑表达式也应该得到简化&lt;/p&gt;
&lt;h2 id=&#34;状态机switch红绿灯的简单应用&#34;&gt;状态机：switch红绿灯的简单应用
&lt;/h2&gt;&lt;p&gt;状态机：管理复杂状态的转换，使用switch case&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b016/jsw2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b016/jsw2_hu_b280ac8ecd0095c1.png 480w, https://airmuamua.github.io/hugoweb/p/b016/jsw2_hu_8155b5fd86344a31.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;switch红绿灯的简单应用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在实际情况当中肯定会把这些括起来，变成函数。函数相当重要。&lt;/p&gt;
&lt;p&gt;在企业当中呢我们肯定不会用这种简单的方式，就会有一个枚举（后面会讲到），用枚举来控制状态机的状态。&lt;/p&gt;
&lt;h2 id=&#34;switch-case与if-else的根本区别&#34;&gt;switch-case与if-else的根本区别
&lt;/h2&gt;&lt;p&gt;它虽然都是根据不同的条件执行不同的代码块，但是它们在语法用义上其实是有差别的。我给大家讲的第一个区别就是，&lt;/p&gt;
&lt;p&gt;if-else语句是基于布尔值来控制流程的对吧，基于括号里的布尔值。&lt;/p&gt;
&lt;p&gt;而switch_case语句它更像是什么呢，它更像是基于一个表达式的值来控制流程。&lt;/p&gt;
&lt;p&gt;而if里面的值不是表达式的值，他是布尔值，它是基于布尔的表达式来去控制流程。而switch更像是一个值进行比较。说白了switch里面这个操作，要求必须是整型。&lt;/p&gt;
&lt;p&gt;所以if-else适合什么呢，适合各种条件检查。你需要的你能想到的条件检查if-else都可以通用。那switch不可以&lt;/p&gt;
&lt;p&gt;你if-else也可以设计到检查范围，比如说大于一个数并且小于一个数，我只需要一个逻辑与就可以了，我&amp;amp;&amp;amp;一下就OK了。或者是由多个条件进行或者或组合的时候，if-else条件是通用的。&lt;/p&gt;
&lt;p&gt;但是switch就不一样了，它更适合有一个变量，或者有一个特定的值去对比，去套用。跟坐电梯一样我摁个五楼到五楼了，我嗯个四楼我就到四楼了，还需要用这种东西。它通常用于什么呢，同一个变量对不同值有不同的反应。你比如说我按着五就是五，摁个六就是六。所以我跟大家讲switch的逻辑就是电梯，大家记住电梯的逻辑就是switch-case。&lt;/p&gt;
&lt;p&gt;那么还有一个就是我们从这两个方面去对比它的可读性和维护性。对于复杂的条件逻辑或者说不同之间有逻辑的关联。你比如说范围检查要么大于一个数并且要同时小于一个数的时候，那if-else会更加直观。但是switch这种情况下它就不直观了。因为有一个变量或者是有很多很多的可能和比较的时候。&lt;/p&gt;
&lt;p&gt;switch当有一个变量和一系列不同的值需要去对应的时候switch才是一个好的选择。逻辑判断非常复杂的时候可能就不是好的选择。switch会使每一个分支拥有的条件会更明显。&lt;/p&gt;
&lt;p&gt;那么在某些情况下，刚才我说了，switch可能要比多个if-else的话，它的性能会更好，就是因为它不用走多余的行，不用走多余的路。尤其是case值比较多的情况下，它的性能要远远大于if-else。&lt;/p&gt;
&lt;p&gt;但是在现代的计算机和现代的编译器当中，这种性能是微不足道的。而且现代的编译器，你可能用的比较先进的编译器，包括vs也是，它对if-else链进行优化了，所以这个性能上是微乎其微的。但是你要知道从原理上来说，这种情况下有多个分支，switch-case还是要比if-else要好。&lt;/p&gt;
&lt;p&gt;不仅是性能上，从刚刚我们说的这些情况，可能也是用途不一样。&lt;/p&gt;
&lt;p&gt;那么还有一个区别就是它m默认的行为上有区别。你比如说if-else语句它不需要有默认的行为。如果说if-else所有的条件都不满足，那代码就可以什么都不做。或者是大不了就else出去。那么switch-case语句呢，默认就有一个default。这就有点像else了。if-else它可以不需要else，但是switch不行，switch必须要有一个default。我不管，哪怕你只有一个break。它是必须要有一个默认的分支，用来去处理没有case被选中的清况。它默认行为是不一样的，这是我给大家讲的。&lt;/p&gt;
&lt;p&gt;这就是if-else和switch-case的根本区别，希望大家能够真正意义的通过刚才我们去写练习的这些案例，来能够区分现实在企业当种编程switch-case和if-else的根本性的应用场景区别。希望大家能够有所体会。如果大家觉得这些案例不够深刻，每个案例多练几遍。可能是我写的这些代码呢你就写了一遍，你多写个几遍。注释你也不要放过，你写的时候呢先把注释写上，然后看看自己能不能把这个逻辑写出来。这也是一个训练。先把注释写出来，在自己写一写，看一看，那兴许你会写的比我好。&lt;/p&gt;
&lt;h2 id=&#34;第四章结束语以及警示&#34;&gt;第四章结束语以及警示
&lt;/h2&gt;&lt;p&gt;对啊，if章节呢，条件的这个选择啊，我们算是这个上完了。是不是觉得非常快呢？其实条件也就这样，嗯，但是我希望呢，大家课下的时候啊。我们这个案例啊，应该多练习。直到你能够什么呢？能够把咱们这几节课敲的代码理解。相当的关键啊，因为每一每一块儿啊，基本上都是说啊。我去想去构思，哎，怎么把这个案例给他整出来？然后大家去注意一些细节，那么这一块的知识呢，很有可能在学校里是不一定听得到的，哪怕说你在互联网上不太容易能听得到的啊，就是可能会有也有一些细心的人去做。&lt;/p&gt;
&lt;p&gt;这一章做个总结，就是说卫语句这个东西啊，其实是相当重要的啊，就是尤其是我举的那几个例子啊，包括这个卫语句的使用是相当关键的。就是卫语句的使用就直接影响到我们if-else掌握的可能，因为我们有时候判断逻辑的时候，可能不是从他满足条件就开始满足条件，可能就那么几个，有时候可能从不满足条件来去判断，卫语句这个使用的技巧，我希望每个人都可以掌握啊。&lt;/p&gt;
&lt;p&gt;那么除此之外呢，还会有一些练习啊，你比如说有些同学喜欢在这个网络上去寻找题，你们可以去看一看关于这块的这个练习啊。这个搜索当中呢，有很多啊，包括这个博客教程啊，很多很多，我们可以看一下人家这个。我希望你们多多去看一下啊。这些练习的，你们也可以跟着去做一做。这就是相当好的啊，是相当好的，因为最起码有一个训练啊，这很重要了啊，很重要。有的时候学校给的那些那些训练题啊，其实我觉得有的训练题其实意义不大的，没有训练出学生学习的掌握if重点的关键所在，还有这些技巧所在，他反而给学生一个不好的一个案例。那反而让学生去能够，哎，你学生没有去注意哪些东西是在企业里是不规范的，你的题目反而提醒他，你没有提醒他，你题目上写着。他可能就以后写代码的时候也会这样写，那这样肯定是显而易见是有问题的。&lt;/p&gt;
&lt;p&gt;所以这个也是教育所存在的一个问题就是啊，教育当中的测试与考题与现实生活与现实职业生活是严重脱轨，可以这么讲，严重脱轨是吧。你说你去菜市场去买东西，菜市场去买菜，那你微积分倒是学的挺不错的，可是你不一定能够有大妈好忽悠。那卖菜的那些大妈可比你精多了啊，他比你精明的多，他知道怎么算计的你死死的是吧？我觉得你学了微积分也不一定管用。&lt;/p&gt;
&lt;p&gt;就是说考试考题这个测验啊，基本上都基于这个过去的这些职业证书和这些教育经历。也就是说，现在教育最大的问题是什么呢？就是说教育界有一些什么证书啊，或者是有一些比赛啊，有一些考题，他出来之后，他是根据过去的这个经验和过去的这个标准来去衡量的，而不是根据实时的去衡量的。因为他永远不可能跟得上。不可能跟得上的，教育是永远不可能跟得上实际实时输出的，是不太能的。&lt;/p&gt;
&lt;p&gt;教育能做的事情仅仅是能够激发学生的兴趣，能够让学生更容易去理解这些东西。教育能够把这些东西讲出来，这个原理讲出来，我觉得这个教育就已经相当不错了。能把这个原理给讲出来，这点相当不错。但是，你要说可以跟得上这个实际的这个用途啊，或者是干嘛的，这个可能性是比较小的啊，是比较小的。因为获得这些教育资格的人就是教师，不是我有意诽谤，事实这样的。获得这些教育资格的人，比如说教你东西的，说白了就是老师了。老师这个职位他是通过什么来去获取呢？它是通过教师的资格。那么教师的资格这个考评是根据过去的标准。没错，全是过去。如果他可以跟得上社会的标准，那他为什么去当老师？这是一个问题啊，他进不了企业。就是如果说你的教师他进不了谷歌，进不了微软，那他只能去做老师。那他所学习到的这些知识都不是现实生活中中去用的，也没有经历过企业当中的开发案例。所以一层套一层。教师的筛选，学生的筛选，教育的筛选，几乎都是不合格的。这个是没有办法的，改变不了。&lt;/p&gt;
&lt;p&gt;唯一能做的事情呢，就是像我这样的人更多的站出来，去能够被做一些小小微薄的工作，做一份微薄的援助。希望大学的教师，大学的学生能够。听到我讲的这些知识之外，还要能听得到我讲的这样的东西，我告诉你，你可能已经不太符合规范了。哪怕你再去企业里面，校企可能会有一些合作吧，你可能身为教师，你能去一些企业去培训一段时间。哪怕你去培训，那么其实说句实在话，你也没有实际的开发经验。后期教学呢，这是一个问题，那除非像我这样闲着没事儿的，出来给大家讲讲。&lt;/p&gt;
&lt;p&gt;当然秉承着你去学习的这个态度。你要知道，你投资学习是投资给自己，不是给别人的，对吧。这些东西全都你可以学得到，OK，我们就讲到这啊，关于这个条件判断。我希望能够除了我在课上讲到的这些案例之外，应该是多写。至少是我课程上的两倍，没有开玩笑。因为接下来我们所讲的这些内容呢，理论知识其实来说，因为我对都质量啊，还是比较有信心的。&lt;/p&gt;
&lt;p&gt;所以教学如果在理论知识，或者说在这个难点，不容易理解的地方，大家不用去担心。我担心的反而是缺乏足够的训练。就是你们课上去听我去讲，听老师讲，听别人去讲的时候，可能疑点重重也听不懂，很难。但听我去讲的，说你下点功夫稍微搞一点，这就是你稍微听听就可以听懂了。能听懂不代表你就会了，你要把这个知识转变成自己的。&lt;/p&gt;
&lt;p&gt;有些同学呢，可会做一些笔记啊。其实这个笔记，我觉得笔记是给自己看的，不是给别人看。你给别人看写得可漂亮了啊。那有什么用？你毕竟是给自己看的，对吧？所以你要知道你记那些东西是干什么的。笔记这一块呢，我会在另一篇中写到，《IT行业学习的方法》你们可以去看那一个，小几千字啊，非常的牛啊。&lt;/p&gt;
&lt;p&gt;那么还有一个情况，我要跟大家讲就是，训练，还是他妈的训练。没别的了，我希望你听了这些内容之后，你能做出大量的训练。如果说之前的一些各种各样的运算符你还是有点吃紧，就是突然用到这个运算符，你突然就很懵逼，没有搞懂。你反复看了几遍才搞懂。那你可能对这块不太熟练，你可能就需要多敲，多想多敲。不是说你单单去理解。而是理解的同时你要去多训练，这个是相当重要。你要去写。&lt;/p&gt;
&lt;p&gt;有些同学是，光理解了，缺乏足够的训练。我课程上讲的这些案例固然重要，但是你要知道，有很多的案例很多东西需要自己训练。包括在网上去搜一搜相关的这些练习，可以可以练一练，试着去写。&lt;/p&gt;
&lt;p&gt;那么像学校啊，给的这些选择题，填空题，改错题，或者是让你告诉你输出几这种情况，我就觉得。你是用人脑再去计算这个逻辑是不假的，但是从理论上来说，是告诉你这个程序执行的逻辑是怎么样的。就是这些选择题、填空题、改错题也好，其实它只是能够训练一点点微乎其微的东西。就是训练你的逻辑，训练这个程序，它到底是怎么个执行的流程。但是对于这个程序，他为什么这样写，而且题目当中给的X、Y这种变量是模糊的，没有任何的训练结果。&lt;/p&gt;
&lt;p&gt;所以我需要你们能够遇到一个自己觉得我做了这道练习之后，我觉得这个案例很好，这个案例我学到很多东西，我虽然错了，但是我学到很多东西。那这个东西你就要去上手去敲一下。然后呢，把它那个变量名改成尽可能标准一点，适当一点。我相信有一些同学是这样去做的，那我就得恭喜你了。因为你确确实实在去做这件事情，就跟这个改错本有点类似了。但是他不同于改错本的是，改错本只是纠正习题，总结习题。但是你真正的目的还是得到了训练，这个是相当重要的。这种情况你就很快能掌握这个节奏。&lt;/p&gt;
&lt;p&gt;那有的时候你发现你代码敲不下去了，你不知道该怎么去下手，第一个方面就是你训练太少了。你能否理解它是一个问题。第一个问题就是能够理解，第二个问题就是你能否理解的同时去把这个程序，它的逻辑，去想出来。第三个就是你能不能敲出来。&lt;/p&gt;
&lt;p&gt;那么后面两个，一个是需要去思考，一个是需要训练。两个都少不了，第一个只是理解而已。只不过大多学生卡在了理解上。是真的，然后绝大部分的学生稍微理解了之后，就卡在了第二步。所以他写不出来。就是因为他缺乏足够的思考，同时他更缺乏训练。&lt;/p&gt;
&lt;p&gt;所以这三个当你都去做的时候啊，你就越来越去得心应手，它需要一个过程的。它不是立竿见影的，它需要一个过程。&lt;/p&gt;
&lt;p&gt;你比如说一个if-eles这些案例，不同的案例到底做了多少，我觉得你至少得有五六十个吧.大家觉得我靠，说的太夸张了。差不多吧，也就五六十个，你觉得这很多实际上不多。你在学if-else的时候你可能花了一周的时间。那一周，你多去练一练，多去写一写，其实实际上也没有花多长时间。那要不然就10天，一天就5道，一天就三四道的样子。你总得有一个信念，你不可能说没有信念，没有思考，没有训练，这是不行的。有些同学呢，光有训练了，没有思考，就是看网上这个代码敲出来了，或者是看我敲这个代码，然后你跟着对照去敲，敲完之后呢，你没理解我为什么要这样写，那也不行。&lt;/p&gt;
&lt;p&gt;所以大家清楚，第一步是理解，第二步是能够理解这个理论知识，理解这个背后的逻辑。第二步是什么，去思考思考他为什么要这样写，对吧。我理解了之后，如果没有代码，我能不能想出来到底怎么回事，这个逻辑能不能想出来。第三步就是足够的训练，然后把代码写出来。这三步相当重要，少了一步都不可以。&lt;/p&gt;
&lt;p&gt;所以编程这个东西其实就是循序渐进的过程。它不是一个说你学了，学懂之后然后你想一想就会了。不是，他需要去训练。&lt;/p&gt;
&lt;p&gt;我们这节课就讲到这，关于这个if-else这个逻辑，我希望大家能够有所训练。这样的话，你了解这一块知识，这个方法论，那后面的话就很好办。因为我们的后面在学这个for，纯粹就是训练，没有别的for语句。你说这个东西，很多人都觉得循环很难，就后面我们就学到循环嘛，很多人觉得循环很难，其实循环不难。第一步是理解循环的机制，为什么要有循环。第二步是理解循环能解决什么样的问题，第三步是循环有哪几种方式，我该使用哪种方式，第四步是如何理清楚循环当中的这些逻辑。第五，如何用循环去做一些训练。这五步掌握完了之后，循环其实你做的已经相当棒了。至少是学完了啊。可能说后面还有指针啊，还有数组啊，那是后面的问题。&lt;/p&gt;
&lt;p&gt;有人说学了这些东西能就业吗？我明确的回答你，不能。因为就业呢，需要有很长的职业规划，而且还需要有一些相当的职业目标。我可以这么告诉你，这些课如果不学的话，你不可能就业。我可以这么讲，就学了这些课之后，你能不能就业，那是一回事儿。有的人确实学了这个就业了，也有这个这样的案例也不多。因为我说的很清楚，有一个职业目标应该会更好一点啊。那么如果说你今年刚大一或大二，嗯。其实都还好了因为你刚步入大学其实更要紧的是能够掌握大学的学习节奏可砍掉一些不必要的东西包括平衡自己的生活这一方面，我觉得应该是大一新生应该要着重要强调的。那如果说你大二了那你就应该逐步的去了解自己再去学什么，再去做什么，自己要去朝着一个目标什么职业规划去努力。那么这个不是我们这节课的重点啊。祝你好运。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【C/C&#43;&#43;】C语言「第三章」</title>
        <link>https://airmuamua.github.io/hugoweb/p/b015/</link>
        <pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b015/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b015/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89-%E7%AE%80%E5%8D%95%E7%9A%84%E8%83%8C%E6%99%AF.png" alt="Featured image of post 【C/C&#43;&#43;】C语言「第三章」" /&gt;&lt;h1 id=&#34;第三章&#34;&gt;第三章
&lt;/h1&gt;&lt;h2 id=&#34;运算符的介绍&#34;&gt;运算符的介绍
&lt;/h2&gt;&lt;p&gt;运算符这一章节其实实际上是最简单的一章节，很多人都觉得运算符他妈的很傻逼，那是因为你考试傻逼啊不是运算傻逼。表达式和语句的话我们不按照书讲啊，因为没有任何教材能符合我们的标准啊，包括市面上你能见到的书都不符合我们的标准。至于表达式这种东西我们前段时间在C语言教学的前面已经讲了什么叫表达式（expression）什么叫语句（statement），所以我们这里就不多说了。&lt;/p&gt;
&lt;p&gt;那么书籍的话一般会分为这几大类，一类是基本运算符、一类是其他运算符（我们可以理解为关系运算符）。也就说运算符在C语言当中有四大运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算数运算符，算说说白了就是用来加减乘除的是吧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系运算符，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑运算符，非（!）与（ &amp;amp;&amp;amp;）或（||）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值运算符，=&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据对象与左值和右值&#34;&gt;数据对象与左值和右值
&lt;/h2&gt;&lt;p&gt;变量为左值，数据为右值把右边的丢给左边的&lt;/p&gt;
&lt;h2 id=&#34;多重赋值&#34;&gt;多重赋值
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jfz1.png&#34;
	width=&#34;1853&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jfz1_hu_d274d73220439b89.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jfz1_hu_ccde4ae9c1fc1c58.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;这里也注释了x,y,z仅作为测试程序&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;239&#34;
		data-flex-basis=&#34;575px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jfz2.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jfz2_hu_7116d4622865553e.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jfz2_hu_5aabd22b01829ddb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;结果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;想象一下，你有一桶漆三面墙。你现在要给所有的墙都涂上相同的颜色，但是它是有步骤的，你要按顺序来。那么在C语言当中我们有一个说法叫做多重赋值。这个多重赋值就相当于这个意思，一次性给多个变量赋上相同的值。但是呢不好意思的是我们在C语言当中，他赋值的时候是从右边往左边去赋值，他是这样一个过程。&lt;/p&gt;
&lt;p&gt;多重赋值就是考试的时候，中国的考试可能会有内陆的考试可能会有多重赋值。说白了就是闲的没事找事，真正程序的时候不会这样写，允许通过但是不允许这样去写，你要知道它的原理是什么啊。所以我们在真编程的时候只会把每一个变量分行去赋值。当然这个变量名也是毫无意义的，这里也是不应该的。因为你在公司里写代码一个团队写代码别人不知道x，y，z是什么东西。&lt;/p&gt;
&lt;h2 id=&#34;复合赋值&#34;&gt;复合赋值
&lt;/h2&gt;&lt;p&gt;比如说expression1 += expression2可以理解为 expression1 = expression1 + expression2，复合赋值运算符将会导致原地修改。&lt;/p&gt;
&lt;h3 id=&#34;选修&#34;&gt;（选修）
&lt;/h3&gt;&lt;p&gt;但是啊它们有一种微小的差距，这最后的结果上它是一样的，但是某些情况下，像复合赋值运算符它可以提供更好的性能，还有一个就是更清晰的代码意图。为什么，因为复合赋值语句从表面上来说就是要把这个变量值给它原地修改了对吧。什么叫原地修改，就是让它自个加上另一个东西或减去另一个东西或乘以另一个东西，说白了就是我原本的expression1，在它自个身上做出一个运算，再复制给它自个，就是对它自个进行修改，然后呢再赋值给它自个，这种叫做原地操作。像这种复合运算符，直接了当，一下就知道了。我表明了这个变量要在原地上被修改，然后再赋值。但是expression1 = expression1 + expression2这种情况它表示为什么呢，它表示为右值相加计算完成之后再赋值给左值，它有这样一个意义。但是如果我们是符合赋值语句的时候，它的意义就非同凡响啊，虽然结果是一样的。它的意义是什么，在它自个身上做一个运算，相当于变量要被原地修改，是这么个意思。但是我跟大家讲，现代编译器通常能够优化这个问题。你比如说我们后续不是简单的这种加减乘除这种操作，我们后面会学到结构体（后面会学，现在不学），还有一个就是面向对象语言当中比如说C++或者是Java这种，大型的类或者是一个object（如果你学过Java就知道了有一个对象）。那么复合运算符可能会避免不必要的对象复制，它直接原地修改了对象，然后从而提高性能。就是说它不比拷贝一份做出计算，在原地上修改，做出了一个性能的优化。所以从本质上来说如果你想要原地修改这个变量的值，你就使用复合表达式，第一从代码的阅读来看它是好的，因为更直观。你告诉他们你就要原地去修改这个东西然后复制它。第二它从性能上从现代的编译器乃至从其他的高级语言当中可以提高性能，明确的告诉人们变量将在远地方的位置被修改，尤其是在对代码维护理解上或者说涉及复杂的表达式和大型的对象和类的这些迁移或使用的时候，这个代码的清晰度可能是要优于另一种方式。那么在英文当中呢我们有一个词，软件工程有一个词叫做 In-place Modification 原地修改，它就意味着变量的值将在原始的存储位置被更新，而不是在另一个位置简单常见一个新的值做出计算然后再将新的值赋值给原先的值。&lt;/p&gt;
&lt;p&gt;那么它在C语言当中，我们初学者后期可能会用到的是什么，数组和指针可能会用到。你学到后面的时候可能会用到复杂的数据结构也会用到复合赋值运算符，因为它的性能它不会单独去拷贝一份出来去计算。所以你要知道啊，它的优势在哪里，就在这里。我们后续的时候，课程的最后几章会学习到结构体，我们那时候就会很清楚为什么啊。&lt;/p&gt;
&lt;h6 id=&#34;开骂题外话&#34;&gt;（开骂）题外话
&lt;/h6&gt;&lt;p&gt;C语言它之所以有这个东西的存在就说明它有存在的必要性，它在某些场景上会用到。只是大学不会去教这样的东西，因为大多数的大学教师呢，它没有去企业参加过企业的项目开发，所以这些东西他很难去用到。那么这也就是为什么大学从来就不告诉你，学这个东西它到底有什么用，这些东西会用在哪，咱们的每一刻我都会告诉你这个东西的用途在哪，用最简单的案例告诉你这个东西是有用途的。虽然这个代码简单，但是它就是很实用，它就是在企业当中都是活生生的案例，它就是应用的场景是活生生的，你不得不重视它。那么很多人都会说我学了这个东西它到底有什么用，包括很多人会问我说我学数据结构到底有什么用，我没开出来有什么用。是因为教你数据结构的人他没有在企业开发过，他不知道数据结构会用在哪，这是非常可怕的。就是我学了之后我学懂了没有？是一个问题。我学会了没有？是一个问题。我会用了没有？是一个问题。我知不知道它在哪？又是另一个问题。所以这个相当重要，我可以告诉你学而不用就是白学。&lt;/p&gt;
&lt;h2 id=&#34;算数运算符的应用&#34;&gt;算数运算符的应用
&lt;/h2&gt;&lt;p&gt;没什么好讲的，就说一个%取模，就是求余数，当然你得是整数不能是浮点数&lt;/p&gt;
&lt;h2 id=&#34;一元与二元运算符&#34;&gt;一元与二元运算符
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyy1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyy1_hu_22367e284dd0caef.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyy1_hu_3762b154577ea9a1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;一元运算符&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;它的含义是什么呢，一次运算只需要操作一个数。你比如说我这次操作只操作了number_1，所以说呢这个数就是- -10，这个操作整体是一个右值，那这个操作他就叫一元，因为它只有一个负号。&lt;/p&gt;
&lt;p&gt;但是有一种情况就不一样了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyy2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyy2_hu_8b1e702b03f1438b.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyy2_hu_6f3210be766a3621.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;注意看total_number&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这里的减号就不一样了，之前的代表的是负数取负嘛对吧，那你这时候是什么呢，是取减。那注意这个时候我们是有区别的，有什么区别呢，大家看我这里是操作两个数。因为我这里减号是什么，两个数的操作作为右值，我number_1减number_2就意味着我操作的是两个数，所以呢这里的这个减号称之为二元运算符。&lt;/p&gt;
&lt;h2 id=&#34;前缀后缀递增与递减&#34;&gt;前缀后缀递增与递减
&lt;/h2&gt;&lt;p&gt;那么因为递增运算符和递减运算符在我们后续当中循环里可能经常会使用到，所以我们在后续的循环的时候会继续再讲循环里怎么去使用它，那我们这节课就只是来认识它，要求去掌握它基本的原理常识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jqh1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jqh1_hu_4a81788c0c3f8fe2.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jqh1_hu_8636f042420b97d3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;很直观&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;所以你要清楚这个前缀和后缀它处理的方法是不一样的，它不能等同于。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jqh2.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jqh2_hu_8fd5f0c00ed1c083.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jqh2_hu_9747672466363eb0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;所以这个时候是很显而易见的啊&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么还有一个所谓前缀后缀递减，其实也是一样的。所以大家都知道啊，这递增递减是这么来的这么用的，这个很重要。&lt;/p&gt;
&lt;p&gt;那么在企业当中这个递增递减的作用应该尽可能的去避免，尤其是更复杂的语句中，不论是什么作业递增我们都尽可能的去避免它。因为它不清晰，你不知道他是先加还是后加能理解吗，不像大家想的那样，很复杂。假如说++value++，那到底是谁先加谁后加，那假如你这里再有一些其他的运算，像是++value * 5 ^ 6这种很容易把人搞蒙，所以在企业当中尽可能去避免++的这种写法。除非是用到循环里，我们后面会讲到循环的时候那些自增变量可能会用到，那除此之外呢可能定义数组的时候我们可能也会用到，但是在企业里尽可能不要去使用这种方法。&lt;/p&gt;
&lt;h3 id=&#34;选修题外话&#34;&gt;（选修）题外话
&lt;/h3&gt;&lt;p&gt;就是考虑性能的考量的时候现在的编译器虽然说可以优化前缀和后缀的差异，但是实际上前缀递增和递减可能比后缀递增递减的性能更有效率。但是我们初期去考虑到如果我们的表达式过于复杂，你可能说它算数的比较多，我们尽可能的不要是用这种++的这种前缀和后缀的，会造成一些歧义的形式。因为我们后面马上会讲运算符的优先级，那我们有的时候可能带括号对吧，要是再算个加减乘除取模啥的，那我们就懵了。它到底是算完模之后再加还是先算完除法之后再加那这个就是我们很难去考量的。就是我们人的头脑的逻辑是很难去排查这些隐患的，所以我们要尽可能的去避免这样的隐患。而且++这种东西我们甚至可以不用。我们甚至可以value +  1这是最清晰的。&lt;/p&gt;
&lt;p&gt;所以说有一个说法就是选择前缀和后缀的形式是否基于要变量的旧值这个很重要啊。我们有一个术语叫做旧值，旧值的意思就是说原本的变量的值。那如果说我们本来不想去改变这个值的话，那我们可能就要去想办法去处理这些问题。所以我们就要考虑留下来旧值在后面会不会用，你像我们这个旧值在后面的时候就会用，能理解吗。&lt;/p&gt;
&lt;h2 id=&#34;按位移位运算符&#34;&gt;按位移位运算符
&lt;/h2&gt;&lt;p&gt;说实话，按位移位运算符对于初学者来说对于基础的开发者来说其实不是特别常用，但是会有的。按位移位运算符这个东西它会在什么地方用到呢，大家都知道C语言当中咱们编程语言的能处理的是什么，是不是二进制。那么C语言里面提供了一个按位移位运算符它就用来处理二进制数据的。大家想一下，如果数据是一排一排的小方块，就代表着0或者是1，那么按位这个操作符是什么意思呢，就相当于是你要用一个操作符去发送命令，命令它是向左移动还是向右移动，指定的位置。它就是直接去操作一个二进制数，而且操作的是一个二进制数的位置。那么其中的有两个运算符，也就是&amp;laquo;（左移位运算符，表示向左移动指定的位数，每个位向左移动，低位补零）和&amp;raquo;（右移位运算符）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw1.png&#34;
	width=&#34;1919&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw1_hu_1396953fde961154.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyw1_hu_e82393714f85e9df.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;显而易见&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;注意我们这里定义的是&lt;strong&gt;uint&lt;/strong&gt;类型，所以我们在企业里去用位移代码的时候一定要保证你的意图，特别是要注意符号位可能会溢出。我们这里单独还写了&lt;strong&gt;uint&lt;/strong&gt;，因为确保他是无符号。&lt;/p&gt;
&lt;p&gt;那么还有一种情况就是会导致&lt;strong&gt;数据溢出&lt;/strong&gt;，特别是左移。那么右移的现象你要考虑到有可能右移的时候这个数会变成有符号的。&lt;/p&gt;
&lt;p&gt;位移可以替代加减乘除的运算来&lt;strong&gt;优化性能&lt;/strong&gt;，但是你要清楚你要位移的是个什么东西，这个东西是相当重要的。因为位移操作比乘除计算代价太小了，它不用来回转换，你就动它那些位置就行。你左移一位就相当于✕2你右移一位就相当于÷2，哎有人说我不信这个邪，看刚才的案例。它这个方法是不是比加减乘除要快，因为你要知道你算加减乘除的那个代价是很高的，相对于这个位操作来说这个操作确实是比较高，很显而易见了。&lt;/p&gt;
&lt;p&gt;那么我将带你编写一个程序啊，带你体验一下它的魅力。这个魅力了呢你们初学者估计不太能体现出来。我们少废话，直接上程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw2_hu_65510ef8106af5aa.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyw2_hu_51213f84b50be968.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;左移10位就相当于*1024&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw3.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyw3_hu_2d9afc88c991cb66.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyw3_hu_365c7ec14d9d5c77.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;结果肯定是相同的不用看了，不是相同的我就不叭叭给你讲了&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;按位移位的另外问题&#34;&gt;按位移位的另外问题
&lt;/h2&gt;&lt;p&gt;但是这有什么差别呢，有人说我看不出来有啥差别，很多人觉得这看起来这是妈的一样快啊，都他妈的一下就秒运行啊。我跟你讲啊这个位移它就是比乘法快，我来给你解释一下为嘛，我来给你解释一个概念，听好，有点难。那么在乘法运算呢，在底层硬件我们相乘的时候处理器去处理乘法运算要比加法的位移更复杂，因为它涉及多个步骤，它这个步骤不是像你想的那样，我把num转化为二进制然后就乘以1024的二进制，加减法是这样的但乘法不是。那么我们这里就要扩展一个概念叫做ALU，全称算术逻辑单元（Arithmetic Logic unit）。然后呢这个ALU就相当于是什么呢，在计算机这个CPU上处理器上，咱们今天讲的这个芯片就有意思了，就一个内部的一个关键的一个组件就是ALU，他是一个CPU的一个组件，名字叫ALU。（有人说我是在讲编译原理还是再讲操作系统）它去负责所有的算数运算包括加减乘除。当然还有一些，你比如说AND、OR、NOT、XOR就是我们后面会讲的逻辑运算符，它也是有的，就它也负责这一块，就是四则运算这一方面它也负责逻辑上的处理。就是CPU里呢它会有ALU这么一个东西的存在来去计算这些东西，那么这些东西就可以想象成一个大脑，它用来专门处理所有的数学和逻辑的问题。非常巧妙，这样一个芯片里面就有这样一个东西的。那么知道这个原理就好了，我们继续讲。乘法运算在底层硬件ALU当中是怎么去处理的，首先它要读取这个数，ALU是一个25一个是1024对吧，你想想它在里面会发生什么。但是它去做这个乘法的时候跟我们去做的不一样，跟我们想的不一样。处理器会检查1024的每一位就从最低位到最高位。就是加权法。&lt;/p&gt;
&lt;h2 id=&#34;逻辑的真与假c关系运算符&#34;&gt;逻辑的真与假、C关系运算符
&lt;/h2&gt;&lt;p&gt;真在C语言当中我们用1去表示，假呢我们用0去表示，如果用bool类型去表达的话1就是ture0就是false&lt;/p&gt;
&lt;h2 id=&#34;条件表达式运算符&#34;&gt;条件表达式运算符
&lt;/h2&gt;&lt;p&gt;xxx ? xxx : xxx&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf1_hu_d59aea0c3a8d1ad1.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyf1_hu_eb023083a620d36e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;案例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf2.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf2_hu_c511b98ac6df167b.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyf2_hu_ead735b9779c6907.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;结果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;按位运算符&#34;&gt;按位运算符
&lt;/h2&gt;&lt;h3 id=&#34;按位与运算符&#34;&gt;按位“与”运算符&amp;amp;
&lt;/h3&gt;&lt;p&gt;我们现在定义有两个数啊，第一个数是a=12第二个数是b=25，那么12的二进制是110025的二进制是11001。那么按位与操作是什么意思，什么叫做按位与操作，这是一个判断符。它怎么去判断的呢，比较这两个二进制值。它怎么比较呢，从后往前按位比较，只有当两个同时为1才为1。那最后的结果呢就是1000，但是这个值呢是二进制值，转换为十进制是8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf3.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf3_hu_1e21cb4ec475e406.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyf3_hu_15b41088984db851.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;&amp;案例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf4.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyf4_hu_1ed382df4569762.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyf4_hu_23a8ea148e8a90d4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;&amp;结果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;所以他这个就像刚才我们讲的一样。有人说，这C语言创始人他妈闲的蛋疼，他搞这玩意干什么，这玩意到底他妈有什么用，老师教这玩意到底是干什么用的。我跟你讲，这玩意可有大用了，这个用途跟嵌入式有关。这个按位与操作它可以将特定的位置设置为0，你比如说你想将12这个数它的第二位清零，你可以将12与与一个数相与，这样的话得到的结果就是零。你比如说我举个例子，我为了得到1000这个值，假设我有个数12，那我怎么用12这个数得到1000呢。我按位与啊，我用12跟25与一下得到的不就是一个1000嘛对不对。那同样的如果说我想将一个二进制数的第二位清零，把它变成零。你可以选一个数和它进行按位与操作。&lt;/p&gt;
&lt;h3 id=&#34;按位与或&#34;&gt;按位“与或”|
&lt;/h3&gt;&lt;p&gt;有1为1，只要有1个就是1。&lt;/p&gt;
&lt;h3 id=&#34;按位异或&#34;&gt;按位“异或”^
&lt;/h3&gt;&lt;p&gt;不同为1，0010 ^ 1010 的结果是 1000。只有1个值为0另一个值为1的情况才为1。&lt;/p&gt;
&lt;p&gt;翻转特定位：假如说我有一个数0010我想要1000这样一个结果，那我该怎么办。我翻转过来嘛，把它翻转过来，就是正的变成负的负的变成正的这种感觉。我该跟谁去异或呢1010，我用这个数把它进行翻转，非常巧妙。还有一个就是按位异或来交换两个变量的值&lt;/p&gt;
&lt;h3 id=&#34;选修交换两个数的值&#34;&gt;（选修）交换两个数的值
&lt;/h3&gt;&lt;p&gt;我跟大家科普一个知识，你们当时学变量的时候老师经常会让你去交换两个数的值，他们的代码是这样写的，假如说我们定义一个int a = 1 , b = 2;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;①temp = a;&lt;/p&gt;
&lt;p&gt;a = b;&lt;/p&gt;
&lt;p&gt;b = remp;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;②a = a + b;&lt;/p&gt;
&lt;p&gt;b = a - b;&lt;/p&gt;
&lt;p&gt;a = a  - b;&lt;/p&gt;
&lt;p&gt;这种是通过算数交换的，这个操作其实是比较麻烦的，因为进行了3次计算。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以很多人就觉得这种方法好骚啊，好牛逼啊，我告诉你，狗屁。你进行了3次运算你知道吗，你让CPU运行了3次，而你赋值的个操作你只是让内存开辟了一块额外的空间你只是定义了一个变量而已，你没有让计算机去运算。大家想一想，你开辟一块内存空间和让计算机去运算你想哪个值。当然这也取决于变化对不对，那我们这里经典显然这个案例，最经典的还是temp交换。但是我告诉你还有一种更骚的操作，就是我们今天要讲的通过按位异或符&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;③a = a ^ b;&lt;/p&gt;
&lt;p&gt;b = a ^ b;&lt;/p&gt;
&lt;p&gt;a = a ^ b;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;很显而易见了，通过这种方式呢它就大大缩短了第二种方法的计算量，它就可以直接二进制计算，不用在转化为二进制。当然其实这个效果是一样的，看起来好像也没快多少。所以交换变量这个事我自己觉得还是temp比较好一点，就真正意义上temp啊。所以从这个角度来看的话我们不要去刻意的去做刻意的去处理这个事情，来去搞得好像大家都是很骚操作啊很怎么样，其实不是这样，如果我们重视内存的话，我们不想开辟额外的内存空间，那或许用牺牲运算的速度来去换去一定的空间或者是牺牲空间来换取一定的运算速度它是这样一个决策。这是我们说多了，就是说它是这样一个操作。②和③是原理是一样的。&lt;/p&gt;
&lt;p&gt;那么还有一个就是两个值交换按位异或我讲实话真的就是不太划算，因为我们定义一个变量两个值交换其实际上也就是开辟了一块四字节的空间，那四字节对于内存来说几个G卧槽那算个屁卧槽。&lt;/p&gt;
&lt;p&gt;来我们继续说，检测不同。我们可以按位异或来去检测哎这两个数到底哪个地方是不同的，那这样的话我们可以对比起来啊，它是一个相当重要的观念啊。&lt;/p&gt;
&lt;h2 id=&#34;按位取反&#34;&gt;按位取反~
&lt;/h2&gt;&lt;p&gt;把所有的0变成1把所有的1变成0&lt;/p&gt;
&lt;p&gt;假如说我这里是00001100，按位取反后就是11110011就这么简单。&lt;/p&gt;
&lt;p&gt;应用场景的话，按位取反符在掩码翻转也是很有用的，有的时候会有用。&lt;/p&gt;
&lt;h3 id=&#34;题外话&#34;&gt;题外话
&lt;/h3&gt;&lt;p&gt;这与之前讲的按位移位运算符不一样，按位移位运算符是应用与计算，这个是应用与判断，然后用于调控开关，然后呢运算符里面非常难的我们都已经讲完了，学到这你应该叹口气了啊，所有运算符里最难的东西我们都已经讲完了啊。还剩下一个逻辑运算符，逻辑运算符的话更简单。&lt;/p&gt;
&lt;h2 id=&#34;选修待完善掩码与电路遥控led灯练习&#34;&gt;（选修.待完善）掩码与电路遥控LED灯练习
&lt;/h2&gt;&lt;p&gt;那这个时候我们就要用到超纲的知识了，C语言里其实是没有二进制输出的，但是我们可以自己写一个啊，没错自己写一个。这一块是超纲的知识，你可学可不学，你只需要照葫芦画瓢照着写然后看我怎么用就行了。至于为什么我们后面再去讲，因为这个已经超纲了，超纲了好几章。你就照葫芦画瓢就行了，我怎么写你就怎么写，等到后面的是收你自然会知道这是什么，相信我。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyd1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jyd1_hu_9638d2f768eea156.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jyd1_hu_338a15bc4fe9f541.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;照葫芦画瓢去写一遍&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;c逻辑运算符&#34;&gt;C逻辑运算符
&lt;/h2&gt;&lt;p&gt;这个逻辑运算符真的没什么好讲的，说白了这个逻辑运算符啊，两个and（&amp;amp;&amp;amp;）两个or（||）。它就相当于什么呢，哎，左边的和右边的一比，它也是对比的关系。这两个假如说都为1，那么整个东西就是1，这是and。或的话就不一样了，只要有一个是1，那么整个这个都是1。&lt;/p&gt;
&lt;h2 id=&#34;逗号运算符&#34;&gt;逗号运算符
&lt;/h2&gt;&lt;p&gt;这个运算符其实在后期的for语句当中使用的，就是我们会学到循环的时候会使用的比较多，一般情况下使用的还真不多。我们就简单的写一些小案例啊，就让大家体会一下，就没有什么实际意义，这个程序没有实际意义。但是大家记住只要有意义的程序和变量我肯定写的去规范，不用大家去提醒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh1_hu_e5d8383585e546c6.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jdh1_hu_a0ce072fee62787.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;案例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh2.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh2_hu_2ef92d10f6af94d3.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jdh2_hu_97fcbb9e5daf6166.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;这个result = 4&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;逗号运算符它指什么，这些东西它都会执行。但是最后用逗号赋值运算符的它只会复制最后一次表达式的计算，也就是说，在一行内执行多个表达式，就逗号运算符么它可以在一行里边是吧，一行代码里边执行多个东西，这三个它们都执行没错啊，我们可以看到效果都执行，但是呢它作为一个整体作为一个右值赋值给左值的时候，它只赋值给什么？哎对啦，它只赋值最后一次表达式的计算，也就是最后一个逗号后边的东西，也就是c += 3。就是不管中间有多少它照样都执行没错，但是它作为一个整体右值赋值给一个变来给你的时候它只运算最后一个，就是最后一个逗号后面这个东西返回给它。前面的东西照常进行但是不会加一起赋值给它，所以这个是逗号运算符。&lt;/p&gt;
&lt;h3 id=&#34;选修-1&#34;&gt;（选修）
&lt;/h3&gt;&lt;p&gt;我可以这么讲，就是这个逗号运算符尽可能谨慎使用，甚至不要去使用，甚至不要去在企业里去使用这种。除非你有明确的要求，而且要有明确的注释写的很清楚你在干什么。避免去使用它，因为它的可读性比较差，而这只是其中的一种最简单的用途，那么还有一种用途就是在咱们的for语句循环里了对吧，我们后面会讲。现在你可以不用学，现在你只需要看我装逼就行，说句不好听的就是这样的，因为你现在不理解是什么意思。你比方说我举个例子啊，假如说你们老师喜欢定义i和j是吧，那我们就写你能看懂的，有的人能看懂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh3.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b015/jdh3_hu_7638349d97c7f48c.png 480w, https://airmuamua.github.io/hugoweb/p/b015/jdh3_hu_37b257004e1528fb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;他们有这种操作是吧，乱七八糟的，反正就是让你绕着让你看不懂就对了&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;就是意思就是说我们学到for循环的时候我们这里用到两个逗号，看到没有。它会用到啊，但是只是我们这里不作为重点，因为我现在就告诉你这个东西就可以了。不用你去掌握，后面学到循环的时候你自然会知道这是什么。&lt;/p&gt;
&lt;h3 id=&#34;开骂&#34;&gt;(开骂)
&lt;/h3&gt;&lt;p&gt;所以大家不要担心啊，所以你们看了之后总有那么一两点没听明白的很正常啊。你要都能听明白卧槽，我他妈的还做这课程干什么是吧。你不可能都听明白，不能听明白很正常，要么自己去线下这个看完之后自己去搜索一下思考一下，要么就是继续往下面看，很有可能我后面就会讲。所以你有可能看不明白那很有可能我到后面就会讲哦，这是很正常的啊。你包括我到现在都没有讲scanf，为什么，哎，后面会讲。现在讲起来它太复杂了，不像大家想的那样，我们后面会说一下啊，OK就是这样。&lt;/p&gt;
&lt;h2 id=&#34;计算的优先级和顺序&#34;&gt;计算的优先级和顺序
&lt;/h2&gt;&lt;p&gt;那么这个文档呢都他妈的给我去微软文档里去搜，就搜C语言。就这个文档啊那么别整那些没用的考试，就是真的想不起来了，你就看这个文档就行了。关于运算符的所有优先级这个文档是非常的权威，我就不多说了就是运算符的优先级问题。&lt;/p&gt;
&lt;h3 id=&#34;为什么加号减号一元的运算符比二元的优先级高&#34;&gt;为什么加号减号一元的运算符比二元的优先级高
&lt;/h3&gt;&lt;p&gt;这有一种术语叫解引号，你就可以理解成负号。&lt;/p&gt;
&lt;h2 id=&#34;表达式&#34;&gt;表达式
&lt;/h2&gt;&lt;p&gt;表达式其实我们在最初的时候提过一嘴，所以表达式相当于一个运算的对象，可以理解为常量和变量然后组合进行计算，然后组成的一个东西叫做表达式。&lt;/p&gt;
&lt;p&gt;每一个表达式都有一个值，这个很重要。要想获得这个值，必须根据运算符优先级的顺序来进行操作。&lt;/p&gt;
&lt;h2 id=&#34;复合语句&#34;&gt;复合语句
&lt;/h2&gt;&lt;p&gt;就是一个大括号括起来，可以有好多好多条语句，那就叫程序块、代码块、符合块，你可以这么理解吧。这就是复合语句，妈的没别的了。&lt;/p&gt;
&lt;h2 id=&#34;类型转换&#34;&gt;类型转换
&lt;/h2&gt;&lt;p&gt;我跟大家讲，这个东西它重要吗？我这么跟你讲，等你出现问题的时候你就去翻微软文档，有关于转换问题你好好去看这个文档。这个根本就讲不完，这个东西是没有办法去讲的，就是我们之前讲的那个类型转换其实已经很细了。他这个是更细，就是细到精致啊。这个文档一直都是最新的，你不用担心它会不会过时。&lt;/p&gt;
&lt;h2 id=&#34;第三章结束语&#34;&gt;第三章结束语
&lt;/h2&gt;&lt;p&gt;主要是你要去思考去练习，就是讲的好的代码有案例的，你至少得敲个十来遍是吧。你敲的时候还要去想我为什么这么写，我写这个的时候我干了什么，我提醒大家要干什么，你要这样去想。不然的话你的训练度不够的知道吧。你训练度不够你还以为你没做题反而怪我，这不能怪我。&lt;/p&gt;
&lt;p&gt;当然做题也是一种训练了，之前我就跟大家说了做题也是一种训练，但这个训练效果可能不是那么明显，我给你举个例子。比如说你做题了，你做了这些题你把他更正完了，假如说让你做一个改错题，你把错误改成正确的，你要把这个正确的输入再打一遍再敲一遍再运行一遍跑一遍你才有这个结果。你再看看那个错的结果为什么会错，你就发现你做题的时候跟别人做的不一样，别人是只是选对答案，只是走了个考试这个过场。但是你是真真切切知道这个错误在哪，你知道你在编程的时候不要这样去写。&lt;/p&gt;
&lt;p&gt;那么我建议你们在写题的时候也尽可能要注意啊，这个变量名的规范命名，这个也是没有办法的。我为什么做这些就是为了弥补教育上的缺陷，你不要看我，你跑到国外你都看不到我这样的课程。我就这么跟你讲，你看那哈佛大学录制的什么🐶屁东西，你去看看就知道了啊。不是我说我贬低哈佛大学，那确实哈佛大学是🐂，但是它教学这个东西确实不行，实话实说啊。你把它翻译成中文我觉得没我这个看的爽，我就可以这么讲。&lt;/p&gt;
&lt;p&gt;现在的老师丢失了本质，当然也有些老师确实很好啊，真的是秉承教育的革新啊。这种很少，几乎是没有的，大部分都是在坐吃等死，大学里就是一套教材一套方案用了几十年都不会变的。这个没有办法，教育的本事的制度不改变那其他东西也不会去改变。&lt;/p&gt;
&lt;p&gt;还有一方面就是教师还是太吃香了，说句不好听的混吃等死的人全部都跑到教学里，全部都混到教学楼里了。那真正有才能的人为什么要留在大学里呢对不对，那它有本事去挣钱有本事去做很多事情的时候他就不会继续留在大学里，它就会去到企业里，去到社会里去做一些有意义的东西，他不会去留在大学里。那马云如果当时留在大学里教英语那估计也不会有淘宝也不会有阿里巴巴。&lt;/p&gt;
&lt;p&gt;同样的道理，这个社会有能力的人，我可以这么讲，不会特别多的留在大学里，除非是那种做学术界特别牛的那种人。但那种人他做学术很牛，但他不适合教学。有很多人你们发现就是这些名校他有的时候他教学不是特别好，不是因为他大学不狗好，而是因为那些特别牛的名校那些教授其实他主要的目的不是为了教学，他是为了自己的学术研究。因为他留在大学里他教书的时候学校会给他钱，就相当于是铁饭碗了。给他一定的月薪让他去研究东西，然后呢他借助学校的名誉可以拉拢一些有钱人赞助。赞助的一些项目或者是启动资金，他可以研究他自己喜欢的领域和学术代表。但是对教育的革新我可以说就是0。你不要觉得我说的很夸张，就是这样的。哪怕是世界级的名校都是这样的，很少有人在教学上做革新，几乎没有。&lt;/p&gt;
&lt;p&gt;我可以这么讲，中国大多数计算机的教育有一半至少是中国培训机构的功劳。我是第一次这么夸培训机构，我基本是跟培训机构场反调的。因为培训机构为了赚钱，这两年实在是不干人事啊。就是说你宣传那些流行的东西你会发现最后会成为你的职业瓶颈。因为学生太过于关注流行的东西二不关注于核心的内容，他们只关注半年怎么把一个人训练到岗位上但是没有确切实际的职业生长职业攀岩的计划或者说所谓的规划。你作为自己来说你没有提升的可能，因为你上学的时候就通过培训机构你不知道这背后的原理，内存背后的原理你不懂这些东西，你没有经历过编译原理这些课程，你什么都没有学过你就会有所欠缺，你只是天天是一个拧螺丝就是打工的人。说白了就是我培训只让你去拧螺丝，但是没有告诉你这背后蓝图的设计，这些东西你是没有学到的，你再短短的时间里是不可能学到的。&lt;/p&gt;
&lt;p&gt;那么我可以告诉你的是你在大学里就能学到吗？这个也不一定。但是大学至少会给你一个好的环境让你去学习。那么不好的大学就没有好的环境，就是垃圾啥也不是，就是教学也不行然后教授呢本身也没有什么学术研究了，他可能自己都不碰学术的，就是大学里混吃等死的，尤其是职业院校。并不是说喷职业院校，而是说职业院校也有好的教师这一点我们不可否认。你包括像十几年前C语言视频有一个叫做郝斌的一个职业院校的一位教师做的，这个做的还可以，说句实在话还可以。但是那个时候有人做这样的课程我觉得已经是相当了不起了，我实打实的去尊敬。不过到这个时代的时候啊，随着这个时代的发展呢我们要认识到有些东西它确实是有所欠缺。那么郝斌后来去哪了，是不是退休了我也不知道啊，可能他现在还没退休是吧，有可能就不做了也有可能。但是我们站出来就可说是最好的了，目前这个时代可以这么去理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【杂谈】IT学子的实习之路</title>
        <link>https://airmuamua.github.io/hugoweb/p/b018/</link>
        <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b018/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b018/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%8D%A1%E9%80%9A-%E6%B4%BE%E5%A4%A7%E6%98%9F-%E6%B5%B7.png" alt="Featured image of post 【杂谈】IT学子的实习之路" /&gt;&lt;h2 id=&#34;实习校园招聘与社会招聘&#34;&gt;实习：校园招聘与社会招聘
&lt;/h2&gt;&lt;p&gt;说这个大学要不要去实习，说大二、大三或者说大四就要去实习。我觉得这个都是因人而异啊。你觉得你有能力，你就可以去试一试，万一成功了，你可以学到东西，你觉得大学教不了你什么东西啊，你可以去尝试去实习，提早的去实习，我觉得这个反而是一个好的点，不是什么坏事儿啊，需要你自己去衡量，你自己如果说你学习的能力比其他人学更快，或者说比其他已经赶进度，比其他同学都要快。你可以尝试一下试试，尽早的去实习，尽早的去进入到工作的这个流程当中啊，这样对你的职场可能也会稍微有利，比如说你大三的时候，你去申请微软了，你去申请谷歌、亚马逊，那反而会给你的履历增加一定的这个几率。因为你留在微软，留在谷歌，你都可以随时会有转正的机会。这反而就是说，比后期你去自己去社招面试的时候反而要简单一些，这都是有可能的。所以我想跟大家讲，就是说，如果你还没有毕业，你就尽可能去了解，有一个东西叫校园招聘，这个东西我觉得大家需要了解一下。&lt;/p&gt;
&lt;p&gt;所谓校园招聘就很简单，就是针对实习生的，针对于大学生，还没有毕业生，我们给他一个实习的机会。&lt;/p&gt;
&lt;p&gt;社招就是面向于社会人员了，就是已经有经验了或者已经毕业的同学，已经度过了实习期。&lt;/p&gt;
&lt;p&gt;所以我说句实话，绝大部分同学其实还是没有了解这个知识点，所以就等到毕业之后去找工作，那就是社招。&lt;/p&gt;
&lt;p&gt;就尽可能的你要去走校招。因为你走社招的话，因为你没有毕业，没有经验，你不可能有经验了。&lt;/p&gt;
&lt;p&gt;就说你写的那些东西，你说你自己练了一些“项目”，这个项目应该带双引号，就是说我们为什么这么讲，因为你不管是说从论坛上也好，从这个视频教学上也好，从这个培训机构也好，还是从github上去找这个项目也好，你自己模仿一遍自己做的那东西绝对不叫项目。项目一定是要有团队协作精神的，你没有吧？项目一定是要有开发流程和开发标准的，你没有吧？项目是有开发文档的，你有根据需求跟PM这个沟通吗？没有，你没有版本的控制人，你有用户吗？你也没有用户是吧，你就自己瞎写了，没有用户，那这怎么叫项目呢，对不对。你也没有赚钱，所以这个东西我就感觉这个我就感觉很莫名其妙，就是很多人说我从论坛上，从这个视频教程上，从这个从网站上就是看了一下别人写的东西，然后我自己手敲了一遍，我跟你讲你这个东西顶多叫demo，或者说叫模仿练习，就跟以前咱们说这个小孩爬这个蹒跚学步是一样的，就是一个模仿的练习。你不能把它称之为项目。我就觉得很莫名其妙的就是大学教授，&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【C/C&#43;&#43;】C语言「第二章」</title>
        <link>https://airmuamua.github.io/hugoweb/p/b014/</link>
        <pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b014/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b014/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91Linux-%E5%8D%A1%E5%B8%83%E5%A5%87%E8%BE%9B.png" alt="Featured image of post 【C/C&#43;&#43;】C语言「第二章」" /&gt;&lt;h1 id=&#34;第二章&#34;&gt;第二章
&lt;/h1&gt;&lt;h2 id=&#34;企业实际开发的整形声明stdinth的引用&#34;&gt;🌟企业实际开发的整形声明：&lt;code&gt;stdint.h&lt;/code&gt;的引用
&lt;/h2&gt;&lt;p&gt;实际开发过程中并不会用到&lt;strong&gt;short&lt;/strong&gt; ,&lt;strong&gt;int&lt;/strong&gt; , &lt;strong&gt;long&lt;/strong&gt;，我们该用什么呢，用Linux这些标准。这些标准我们都藏在一个头文件里（&lt;strong&gt;&lt;code&gt;#include &amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/strong&gt;）。我们可以点进去啊，按住&lt;code&gt;Ctrl&lt;/code&gt;点进去，这里面的代码不要动啊，你想动也不行。我们看一下这个源代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/j1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/j1_hu_ebffce62d7ecbf7d.png 480w, https://airmuamua.github.io/hugoweb/p/b014/j1_hu_462005890af6efa2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Microsoft Corporation. All rights reserved C语言的标准库文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;非常🍐🎼啊，这是看C语言怎么编写的，就是C语言的创始人怎么定义这个东西的。我们来看一下，发现有很多的类型&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/j2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/j2_hu_e1d194a0dbb3bf8.png 480w, https://airmuamua.github.io/hugoweb/p/b014/j2_hu_4d764266f74e0289.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这前面红色框我们现在看不懂，因为我们没学到结构体，所以看不懂这些东西，但是我们依稀的可以看到蓝色框这些东西，我们来看一下它有哪些类型。&lt;/p&gt;
&lt;p&gt;那么还有一些其他的，但是我们后面再去学，我们现在没有学到。像绿色框中属于最小宽度整数类型，最小宽度整数类型是什么意思呢，就是保证它至少要有8位、16位、32位、64位的有效。这个以后再讲，一般新手不太可能用到。然后下面黄色框其实还有一些类型，哎大家很清楚的，这个fast的这个就相当于是什么，保证最快最小宽度的整数类型。&lt;/p&gt;
&lt;p&gt;剩下的就不讲了，讲了没用，你们初学者不太能明白这是什么东西。你知道有这个东西就行。&lt;/p&gt;
&lt;p&gt;这个&lt;strong&gt;char&lt;/strong&gt;类型我们现在没学到，所以我们现在就学到&lt;strong&gt;short&lt;/strong&gt; , &lt;strong&gt;int&lt;/strong&gt; , &lt;strong&gt;long long&lt;/strong&gt; 。你看它直接就把&lt;strong&gt;long&lt;/strong&gt;，忽略掉了，因为&lt;strong&gt;long&lt;/strong&gt;和&lt;strong&gt;long long&lt;/strong&gt;它会在不同的编译器下是有歧义的，对不对。所以它直接就忽略了，直接就统一吧，你要&lt;strong&gt;int&lt;/strong&gt;就32的你要&lt;strong&gt;long long&lt;/strong&gt;就64的。&lt;/p&gt;
&lt;p&gt;所以我们现在就来写一下啊，来写一下，走你。我们做一个练习啊，简单的练习。这个练习就是确保我们可以用到这些所有的这些变量（除了char）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/j3.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/j3_hu_ffdd37ee3d9797ca.png 480w, https://airmuamua.github.io/hugoweb/p/b014/j3_hu_71891bdd018fb9fe.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;自己一定要多敲，不要复制，这样才不会忘，一定要自己手敲&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;历史项目遗留&#34;&gt;历史项目遗留
&lt;/h2&gt;&lt;p&gt;其实在企业当中呢，有的人会发现很聪明啊：“很多的这些开源的这些项目其实它并不是都用这样的规范，我就看有些🐂🍺的项目啊。你比如说那GitHub上有Linux对吧，那人家这个Linux这么🐂🍺的项目人家都没用，你为什么叫我用。”肯定会有人这么说，人实际上是用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/j4.png&#34;
	width=&#34;1870&#34;
	height=&#34;979&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/j4_hu_b3c45bbb8c38ee55.png 480w, https://airmuamua.github.io/hugoweb/p/b014/j4_hu_f67ec1da11647e1f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;u8&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;458px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;它写的这个&lt;strong&gt;u8&lt;/strong&gt;实际上是它自己在写了一个，你后面会学到&lt;strong&gt;typedef&lt;/strong&gt;，它自己呢就是说把&lt;strong&gt;uint_32&lt;/strong&gt;或者说把&lt;strong&gt;uint_8&lt;/strong&gt;给写进去了，这样的话它就可以直接去用了，直接去写&lt;strong&gt;u8&lt;/strong&gt;。实际上它写的是什么，哎对，显而易见。有的时候呢你会看到一些比较大的项目它上面写的是&lt;strong&gt;u32&lt;/strong&gt;，其实是一样的，其实就相当于&lt;strong&gt;uint32_t&lt;/strong&gt;,可以这么理解，只是它自己定义了一个&lt;strong&gt;uint32_t&lt;/strong&gt;，普遍的它会这么去写。所以你要知道它这里为什么有&lt;strong&gt;u8&lt;/strong&gt;，因为它自己定义了一个类型。屌不屌。&lt;/p&gt;
&lt;p&gt;有些项目它是用的，有些项目它不用。为什么有的地方用&lt;strong&gt;int&lt;/strong&gt;，有的地方不用。我来告诉你为什么。因为linux是早期的，你要知道Linux是上世纪的操作系统，所以早期的代码库用的都是&lt;strong&gt;int&lt;/strong&gt;类型。因为当时广泛认为这是32位，因为那个时代，在这些操作系统中使用&lt;strong&gt;int&lt;/strong&gt;可以提供最佳的性能。为什么，因为它与当时的处理器的自然字长相匹配，这是历史的原因。所以你见到有一些历史的项目它还在用&lt;strong&gt;int&lt;/strong&gt;或者说&lt;strong&gt;short&lt;/strong&gt;或&lt;strong&gt;long&lt;/strong&gt;这种类型，其实是很正常的，因为他是历史原因。它要保证这个软件能用，你不能说我把这个软件全都改成&lt;strong&gt;uint32_t&lt;/strong&gt;。为什么不可以，因为有的机器，比如说很老很垃圾的这些机器，你Linux操作系统那有些嵌入式的设备还在用啊，嵌入式的设备有的它不是32位它可能还是16位甚至更低。Linux确保最大的兼容性，可以支持更多的设备。所以它宁愿去使用以前的&lt;strong&gt;int&lt;/strong&gt;类型或&lt;strong&gt;long&lt;/strong&gt;类型或&lt;strong&gt;short&lt;/strong&gt;类型它都不愿意去使用现在的这个原因。&lt;/p&gt;
&lt;p&gt;还有一个方面移植是难的。我们知道软件工程当中有个术语叫移植性。什么叫移植性啊，许多项目老的项目都是用&lt;strong&gt;int&lt;/strong&gt;类型，我把它挪过来就很难。因为&lt;strong&gt;int&lt;/strong&gt;类型是所有的C标准当中都可以去用的。但是我们发现&lt;strong&gt;int32_t&lt;/strong&gt;在是什么，&lt;strong&gt;C99&lt;/strong&gt;之后才有的标准。还是那句话，在某一些旧的或者是嵌入式系统当中是可能是不可用的。&lt;/p&gt;
&lt;p&gt;还有一个方面就是它性能的问题。有的就说：哎~他怎么还跟性能有关系。有的啊，如果你要使用&lt;strong&gt;int&lt;/strong&gt;类型，它看起来在现在的软件开发当中是不标准的，因为大家如果说你现在开发个网站什么的，如果你简单的去定义成&lt;strong&gt;int&lt;/strong&gt;它可能不太标准。为什么，就是因为现在软件开发，很少会用到以前的那种老的操作系统去访问。但是Linux不一样，Linux它是有历史价值的，而且Linux它这么多年过来它一直在用，这是不一样的。你比如说你要开发一个网站。那可能你要做的就是符合21世纪的网络流量标准对吧。那上世纪的设备你就不用管了，没有人用上世纪的设备去浏览网页。但Linux不一样，有很多上世纪的设备还在使用，这是分情况的。&lt;/p&gt;
&lt;p&gt;那么在这种情况，有历史的这种遗留，使用这种&lt;strong&gt;int&lt;/strong&gt;类型，通常使用这种例子，我们有一个词叫什么，叫系统，叫做OS的自然字长。就是使用&lt;strong&gt;int&lt;/strong&gt;类型啊，它在这种情况下它反而性能会更好。因为它与处理器的内部寄存器大小相匹配了，这基本上都是32位的。所以通常情况下使用&lt;strong&gt;int&lt;/strong&gt;类型问题是不大的。而且处理这种32位整形不需要额外的转换或者是操作。（后面会讲类型转换的问题）&lt;/p&gt;
&lt;p&gt;还有就是向后兼容，什么叫向后兼容，意思就是说因为C语言当中它不仅仅是有这些东西，你会引入一些stdio.s是不是，你会引入一些头文件。那么其实是在第三方的市场上，你包括像我们这个开源的项目上，有很多大量的库，还有API都使用&lt;strong&gt;int&lt;/strong&gt;类型。如果你去改变去固定它的大小，它可能会破坏现在代码的兼容性。你比如说我这个项目叫A，我这个项目呢我引用了别人的库，这个库呢叫做APIA，那么它这个库呢它里面用的是int类型，这个库可能用&lt;strong&gt;int&lt;/strong&gt;类型，它保证是兼容更多的设备。但是你这个A呢你做了一个&lt;strong&gt;int64&lt;/strong&gt;位的操作，如果你去改写它的函数&lt;strong&gt;override&lt;/strong&gt;，叫重写有一个概念，这个是后期可能有点难了，意思就是告诉你这可能会发生一些问题，这个问题需要你自己去处理。但是不代表说我们就不能用int32_t或int64_t这种东西。反而应该要使用，确定你的产品面向的是谁，这个是很重要的。我举个最简单的例子：网络通信文件格式需要数据对齐，这种场合固定大小是必须的。也就是说你编写网络的一些通信的一些软件的时候，固定大小的数据类型是必须的。就相当于有一个手术，得了病，医生就觉得这个东西还不如不取，开刀把它取出来呢，可能还会危险生命。&lt;/p&gt;
&lt;p&gt;并不是所有地方都一定确保要用，而是现在的软件工程里，用这个的时候尽可能要确定好宽度，如果它不能确定宽度了，我们就不确定宽度啊，要分场合。但大多数情况下我们都是要确定宽度的，就现在来说，以前的不算。&lt;/p&gt;
&lt;h2 id=&#34;隐式和显式类型转换type-conversion&#34;&gt;隐式和显式类型转换（Type Conversion）
&lt;/h2&gt;&lt;p&gt;放在这里来讲按理来说是比较超纲的，但是我就故意偏偏在这个地方讲。因为很多人去讲类型转换的时候，往往是在学到浮点数，甚至是学到面向对象语言的时候才会讲，涉及到类型转换。因为在C语言中的类型转换一定要先去理解，我前面说的这些类型的计算它的范围。如果不能理解的话你是没办法去理解什么叫做类型转换的。说白了就是什么意思呢，我给大家举个例子大家就清楚了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc1_hu_d7bf1ccaaca55e41.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc1_hu_796f56b01d20dd7f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;类型转换的一个案例：隐式转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;大家看，这个案例意味着什么呢，定义了一个&lt;strong&gt;int16_t&lt;/strong&gt;和一个&lt;strong&gt;int32_t&lt;/strong&gt;。那么大家看，&lt;strong&gt;int16_t&lt;/strong&gt;相当于小的一个类型，&lt;strong&gt;int16_t&lt;/strong&gt;肯定没有&lt;strong&gt;int32_t&lt;/strong&gt;这个数据大对吧。32767这是&lt;strong&gt;int16_t&lt;/strong&gt;的最大值了，所以说32比16肯定大对吧。（我tm没吃饭就开始写了）大家注意看，这small相当于什么，相当于我们去超市买东西，我们看货架上有一个东西。small呢就得这东西不错哦，正好呢它能装的下，你看货架上的这个东西啊，每个人推个购物车，small这购物车这么大，big那购物车又那么大，两个购物车不一样大，对不对，它这货在货架上看到这个东西，唉，它觉得这个东西挺好它装到small那购物车上，这是不是第一步，把货装到袋子里对吧，变量赋值我们以前有一个简单的比喻对吧，就相当于这样的是吧，从右边向左边的那种感觉。那么现在问题来了，那么现在big走过来了看见small买的这个东西还真不错，它觉得它也想要，它说“small你帮我也拿一份过来。”&amp;ldquo;啊行。&amp;ldquo;看到没有，就第9行，small呢把它的东西交给了big,它是拷贝一份交给它，他不是把这东西给它然后small没有啦。所以说small它就像它就把这个货呢又拿了一份，拿了份跟它一样的交给了big。那big你说它能吃得下吗，它当然能吃得下，因为这个货就这么大对不对，small吃的下那big呢它更能吃得下，这个意思懂了吧。&lt;/p&gt;
&lt;p&gt;但是有一种清况就不一样了，这样的话就叫什么，有一个词叫做隐式。就是C语言呢它帮我们自动转换了，因为bigNum是int32smallNum是int16，所以它会帮我们自动转换不用我们过多的去考虑。因为刚才我说了是吧，这个small呢这么大，这个big那么的，small要装下多么大的一个货物big都吃得下。这个时候C语言就会自动帮我们去自动去转换就不用去考虑这个问题，这种我们叫做隐式转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc2_hu_916776d68d57cca1.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc2_hu_804d8fa4826da91a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;显式转换、强制转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;到了这个时候他俩就变了，相当于什么呢，把这个大的东西给小的。这个big呢从这个货架上看上了一个东西，蛮大的，差不多有它一半多，它就放到了自己的购物车里了，它觉得自己放的下，没问题。那small觉得：哎，我也要一份这个大彩电，看着挺舒服的。然后呢它看了看自己的购物车装不下好像，因为它的这个数值已经远远超过了&lt;strong&gt;int16_t&lt;/strong&gt;。于是呢，这个big它就开始使坏了说：你必须给我拿下，你看我都能装下，你肯定能装下对吧。显式转换吧，开始画饼了，我能办到的你也能办到。small一听：行，没问题。于是呢这个big就拿了一份它的大彩电塞给了small，这个过程叫强制的，又称为一个叫显式。就交给它，那交给它有一个什么后果呢。我们看最后small的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc3.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc3_hu_895fb31a5e0cd419.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc3_hu_c7a3d6998bb9c51c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;显而易见，这个数就崩了&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;就它装不下这些东西硬要就相当于是一个人的胃口就这么大你非得要给他吃下，强制让他吃，就跟咱们中国的家长一样是吧。不行给我吃，就这种，它就崩了，崩盘了。它扛不住，所以这样就显而易见了。所以我们在这个时候，想要去了解这个程序的时候，我们就要小心了，就是说它不一定有的时候它自动会给我们转，转完的时候它就崩了。那这种情况下，程序编写的过程当中，是不是应该避免这个问题。我们现在只是int16和int32的转换，那我们现在写一个极端的案例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc4.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc4_hu_16039108e2a2b5de.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc4_hu_edc8330a1a2f448c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;大家猜一下结果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc5.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc5_hu_8717c27e995492c6.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc5_hu_b631ccc4bba4398.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;给大家看一下C语言给UINT32_MAX的定义&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc6.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc6_hu_b76f8793e776f482.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc6_hu_dbc498e1d3354fda.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;看到没有，变成了-1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为什么，嗨嗨显而易见吧，因为uint最大值显然和int不是一个。是不是很巧妙，那么我们把它干什么呢，我们现在就是吧uint这个值强制给了int类型。但是我们要记得&lt;strong&gt;uint32_t&lt;/strong&gt;最大值是不是正的42个亿，也就是意味着&lt;strong&gt;int32_t&lt;/strong&gt;它的大致是21个亿，所以它肯定就溢出了嘛。溢出了之后它就会显示-1，你强制转换就像刚才那样，我吃撑了，我装不下了，就报错了。这是一种类型转换的报错， 我给大家解释一下。那么如果我们现在强制给它转会变成什么，怎么强制给他转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc7.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc7_hu_916d5bf684336571.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc7_hu_6c2f9ffd28b51026.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;我们强制在这里给它写上一个(jtc7.png)&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;也就意味着你给我硬吃。刚才是什么，编译器自动去吃，试试看能不能吃进去。编译器认为我吃不进去，然后现在我强行塞给你。我们看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc8.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc8_hu_a2a984af47fe0ceb.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc8_hu_afa069bce317be43.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;结果是一样的&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;因为无论如何它都塞不进去。就是不管是隐式还是显式它都塞不进去。如果我们现在没有(int32_t)，这个叫隐式转换，有就是显式转换，就是我强制把它做一个转换。说白了就是硬塞这种感觉啊。&lt;/p&gt;
&lt;p&gt;刚才是一种无符号到有符号，那么还有一个就是大范围到小范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc9.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc9_hu_cc7287b8222f03d3.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc9_hu_dbbf7dd1959bd547.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;大范围到小范围的强制转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc10.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc10_hu_422459d0916a28de.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc10_hu_3a667027c06e1a05.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;你看也不行，因为它溢出了啊&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么还有一个是什么呢，小范围转换为大范围（扩展负数）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc11.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc11_hu_14041cba4070f5d7.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc11_hu_7ddab249c57e5751.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;大范围到小范围（扩展负数）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc12.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jtc12_hu_d860fd2bff79b064.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jtc12_hu_96c57cb22f273b2c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;大家也都能猜到了，肯定是溢出啊。明明是-1，它给我干到了40多个亿&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这三种情况都会出现问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无符号到有符号&lt;/li&gt;
&lt;li&gt;大范围到小范围&lt;/li&gt;
&lt;li&gt;小范围转换为大范围（扩展负数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么有人说了，那你既然写了这么多那你强制转换的意义在哪呢。有意义，你比如说我们小范围到大范围的。把int16的一个小的正的值给uint32，哎，是不是可以啊。它就可以强制类型转换了。当然这个也可以是隐式类型转换了，因为它可以自动去转换。那么同样的，有人说：啊，你这不是没事找事吗，我明明可以自动转换你要给我强制转换这样一个写法。我跟大家讲，这个写法是非常有必要的。就是我废话了这么多我就告诉你显式转换你要真的想转换你尽可能不要去写隐式转换，就是你尽可能要去写这么一步。为什么，有很多问题：&lt;/p&gt;
&lt;p&gt;第一个，你写成显式转换的时候，这个代码意图更明显。作为开发者你不一定记得代码是什么时候转换的。如果你不看的话它很有可能就是一个值赋给另一个值，因为我们是smallNum赋值给bigNum看起来是一个小的值赋给大的值好像比较明显，但如果说你有的变量它不一定是smallNum和bigNum，你可能定义的A和B那种傻逼的变量你不知道谁大谁小。因为我们知道有大小范围，有大到小的有小到大的还有有符号到无符号的，你这种情况下如果你不写这一步没有写显式，虽然它隐式是可以转了它完成相同的功能了，你可以理解为有这种类似的相同的功能，但是如果你不写和写是两码事。第一个提高代码的清晰度是有必要的，显式转换可以让这个代码变得更明确一点对吧，因为你开发又不是你一个人再开发，好多人都跟你一起去开发，你不能直接就把它变成隐式的，大家不知道你在干什么，一旦出了问题溢出了该怎么办，不知道。大家都在找你的bug，大家都在找你的bug没想到就是这一步，没写啊。很多人都这样，你别笑啊。有的新手到这一步就觉得怎么可能，他笑，有的时候你他妈的以后你就知道了，你学到其他语言的时候就空指针异常很有可能就是因为你这个类型转换的问题。&lt;/p&gt;
&lt;p&gt;那么第二个问题就是什么，它可以处理潜在的转化问题，你比如说我们刚刚这个案例是由小到大的范围去扩展是强制转换这样是可以成功的。可以通过的，而且数据都正常的，但是如果大到小这个范围，如果说我们出错了，我们很容易就知道，哦它会出问题。比如说我写个int32 =123的再把它给int16那就是大到小，大家注意看我的数字是多少，123也就是int16完全吃得下，我加上(int16_t)，所有人都知道我在强制转换，能听懂吧，所有编写这个程序的人都知道我在进行类型转换，我这里是可以转换过来的，因为什么，因为我可以吃得下。但如果有一天有一个程序员吧这个变量值给改了，就比如说改成1231232131312，这个时候就报错了，他就会变成负数。如果有其它程序员再去做这件事情或者哪怕就是你过两天，是吧比如说你昨天晚上喝酒喝多了，今天早上去上班，你说你他妈的怎么变成负数了。这个时候呢你一打开这个程序软件一看，哦这个变量值我做了一个强制转换，有可能这个出问题。然后呢我马上就找到这个变量定义在哪，最后我发现我这个设置是int32我在强制转换成16，说白了在程序里面你真的去开发的时候这个变量很有可能是看不见的，他是一个变量嘛。那有可能就略过了，我就需要注意哪里到底出错了，他是这样一个作用。这是很有用的，不是说为什么我们在真正去写代码的时候一定要去写成显式的而不是要刻意的有一个隐式的。那这样的话隐式当然也可以用，但如果你这里不写，你很有可能会出现什么状况呢。哎呀，这步出错了，怎么回事。哎怎么能出错呢变成负的了，我找不到了啊，不知道在哪，看不见。隐式的嘛，藏起来，看不见。就会出现这种，你写个显式转换，马上就清楚了。那同样的这个无符号和有符号，这个也就都能理解了。你看老半天这些都没懂，无所谓，就这一点你要知道就行。你要知道有显式转换和隐式转换他是有区别的，我们在实际的开发过程当中肯定要写成强制转换的，不然的话报错。你倒霉找不到地是吧。以后学C++或者Java遇到错误，多半是类型转换的问题，拿到前面来讲就是要求你养成一个好的变成习惯，你到后面的话越来越会有体验。你几乎不太可能会在网上看到这样的东西，因为这些都是在实际开发过程当中这样去做的。说实话，培训教出来的东西和这些是不一样的，因为你实际开发当中这些经验是相当惊人的。&lt;/p&gt;
&lt;h2 id=&#34;固定宽度整数类型的格式化宏输出inttypes&#34;&gt;固定宽度整数类型的格式化宏输出inttypes
&lt;/h2&gt;&lt;p&gt;我们之前学的各种各样的固定宽度整数类型，就像是int32_t、int64_t非常的高级看起来很高大上是吧。他们全都定义在什么地方啊，全都定义在&amp;lt;stdint.h&amp;gt;这个头文件里面。就是C语言自带的C99之后自带的。其实在企业里我们很少使用&lt;strong&gt;printf&lt;/strong&gt;去输出了，如果真的有需要输出的我们一定不能这样去输出，因为这样会记错的有时候%llu啥的我们不知道。就是很难是吧，这什么东西每次都要去记。那如果还有其他的就更惨了，本来这个&lt;strong&gt;printf&lt;/strong&gt;所谓的格式化这个类型本来就很复杂了。本来这个语法写的就很复杂了，又是前缀0又是16进制啥的。你这给我搞一下我就更不知道是啥了对吧。那所以说我们就舍弃这种方法，就真正使用固定宽度整数类型的时候我们不使用这种方法来进行输入输出。同样的我们后面会学到scanf，现在不学，因为scanf比较难。很多人都觉得scanf他妈的有什么难的，scanf挺难的讲实话啊。那么现在就使用一种超级🐂🍺的替代方案啊，这种超级🐂🍺的就反正就是装逼的是不是，企业里如果真的去输出的话就绝对不是printf，我们该怎么去输出呢。我们去使用一种比较新潮的方式，就比如说你现在定义了一个int32_t myInt32你要输出啊你就要写了：printf(&amp;ldquo;int32_t : %d\n&amp;rdquo; , myInt32_t)你把那个d改成PRId32，有的人试了就会说哎你这不是画波浪线了报错了啊。我跟你讲哈，你得引入一个头文件啊。这个头文件呢叫做我们学的第三个头文件，#include &amp;lt;inttyes.h&amp;gt;，这样你就会神奇的发现波浪线神奇的消失了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/jpi1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;咱就这么写几条&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;有人说这能输出吗，你给我搞笑呢。来我们走一下看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/jpi2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;可以哦，没问题&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这种非常高级的写法这代表什么意思呢。就代表企业里如果真的有一天会用到printf，真的有一天会用到格式化输出，一定一定要这样写不能写%d的，听到没有。因为这样会直观一点，因为这样大家会知道你在引入什么东西，我们来看一下&amp;lt;inttypes.h&amp;gt;到底写了什么东西。Ctrl点进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/jpi3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PRId32就是d,其它的也是一样的道理&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的话它就很直观，为什么呢，因为我们在这里用的类型名就和它很像对吧。如果真的会用到printf输出的话一定一定这个格式不能简单的填写，肯定是有一套标准的流程的，而这个就是一个标准。你要这样去写非常的装逼啊。但是不是说为了装逼去装逼，而是真的很实用，真的就是这样去写啊。&lt;/p&gt;
&lt;h2 id=&#34;least和fast整型的企业用途与区&#34;&gt;least和fast整型的企业用途与区
&lt;/h2&gt;&lt;p&gt;least定位的时候，保证至少有特定的位数。&lt;strong&gt;int_least8_t&lt;/strong&gt;至少应该有8位，可以超出这个就相当于是≥这么个意思&lt;/p&gt;
&lt;p&gt;fast保证最快的速度&lt;/p&gt;
&lt;p&gt;int leastN_t number 至少有N位，可能最多，适用于需要保证最小存储容量的可移植代码。&lt;/p&gt;
&lt;p&gt;int fastN_t  number 至少有N位，但是选择运算最快的类型，适用于需要性能敏感的场景。&lt;/p&gt;
&lt;p&gt;标准整数类型 - &amp;gt;固定宽度整数类型&lt;/p&gt;
&lt;p&gt;固定的位数，不可以越界，适用于需要精确数据大小的场景。&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数
&lt;/h2&gt;&lt;p&gt;把你他妈教材全给我扔掉，听我说啊，全神贯注现在听我说。乐高你们玩过没，乐高没玩过积木总玩过吧。假如说我现在有一个数3.14159 然后将有这些带数字的积木摆成3 1 4 1 5 9，那现在这样的话还差点火候，差个什么呢，差个小旗子。现在这个幼儿园教师说了你要找到小数点在哪，你把这个旗插在它后面，就完了。&lt;/p&gt;
&lt;h2 id=&#34;char与ascii&#34;&gt;char与ASCII
&lt;/h2&gt;&lt;p&gt;字符类型我放到最后去讲，因为它简单。字符类型从技术层面来看，看起来是存储字符用的。你看像之前我们说的就是存储数字的，要不是小数要不就是整数。那么char类型呢就是用来存储字符的，比如说字母、标点符号那这种都是字符。就存一个，char类型就只存一个。从技术层面来看，char类型其实是整数类型。为什么呢，我给大家解释一下，我们先来看代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jch1.png&#34;
	width=&#34;1853&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jch1_hu_5601373e9cf1fdc7.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jch1_hu_8f70915cb38e0b7e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;马勒戈壁的我也不知道写什么变量好了，我就随便这样写了mych&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;239&#34;
		data-flex-basis=&#34;575px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jch2.png&#34;
	width=&#34;960&#34;
	height=&#34;480&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jch2_hu_2f319c0559ceb6b1.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jch2_hu_600799fd6c7a6a63.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;我们来运行一下走一下&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;显而易见是这样的，但实际上它存储的原理是什么呢。因为大家知道我们计算机只能理解什么，01010101，它只能懂这玩意。你给他一个字母，你给它一个字母它肯定转换。所以本质上它存的还是010101这玩意。那你说0101是啥，这0101不还是数字吗。但实际上存储的是啥，它存储的不就是一个整形吗。你看着它好像是存一个字母存一个标点存一个符号。实际上它存的是一个啥，哎它还是一个int数字。只不过这数字比较小，它只占一个字节。所以我们这里存的实际上是一个数字。很有意思是吧。97就是a，65就是A。有人说大写和小写的怎么计算，考试经常会考这种东西，没用啊。妈的真的无聊他就考这种东西。你说65为什么是大写的A然后97为什么是小写的a，妈的这种题有什么好考的，中间不就差了32么，这妈的有什么好说的，你就记住一个就行了97就是小写的a，你减32，65就是大写的A就这么简单。没别的啊。无聊搞这种事的人都是无聊的人。就是固定死的你减一下就够了没什么好说的。因为你开头32个字符所以说你减32就行了，简单的一逼，没什么好说的。天天就考这些没用的东西这些大学真是神经病，我操不干人事。除了人事除了教学的事，什么都不干啊。这里就讲完了，你就知道它这里存的是一个整形的代表。&lt;/p&gt;
&lt;h2 id=&#34;转义序列&#34;&gt;转义序列
&lt;/h2&gt;&lt;p&gt;转义序列为什么要在C语言当中去引入呢，它就相当于是给程序员一个密码表了。类似于像一些普通的用户，它不可能用到的一些字符，无法去表达的一些控制字符，或者是一些我们上节讲会有一些控制字符，比如说回车换行这种或者说是一些特殊的字符。那这样的话程序员就可以去用了，那当然这些东西在用户面前好像不是特别明显但是程序员要有用到这些东西，那么这些东西呢有一些叫转义序列，其实在计算机早期的时候啊交互主要是考文本对吧，那各个设备的种类、能力都不一样。那么就需要同一种方法来统一处理一些没有办法去打印的字符，什么叫没有办法打印的字符，你比如说像回车、换行、响铃你比如特殊字符“”、\，所以程序员是需要表达这些特殊的字符。在程序里，而不是在文本里。好像文章里大家很少会看到这样的东西对吧。例如\n代表的就是一个换行。为什么用\呢，你看谁他妈一天天写文章用\呢，因为它不常用所以就用它，就这么简单。&lt;/p&gt;
&lt;h3 id=&#34;小插曲&#34;&gt;小插曲
&lt;/h3&gt;&lt;p&gt;printf(&amp;quot;\033[2J&amp;rdquo;); //清除屏幕&lt;/p&gt;
&lt;h2 id=&#34;bool类行与实际案例-stdboolh&#34;&gt;bool类行与实际案例 &lt;code&gt;stdbool.h&lt;/code&gt;
&lt;/h2&gt;&lt;p&gt;布尔类型是相当有趣的一个东西，它原本在C语言当中是没有布尔类型的，直到什么时候才引入的呢。知道C99标准的时候才引用的，所以你见到老谭那本书，中国的很多老的教科书还是没有介绍布尔类型的这是很正常的。但是布尔类型超级的实用，尤其是在现在编程的规范里。引入布尔类型的方式#include &amp;lt;stdbool.h&amp;gt;，这样就可以引入布尔类型，布尔类型怎么去用呢，我告诉你布尔类型他就占一位的存储空间，不是字节就是只占一位。你们看一下这个定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo1.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo1_hu_edced545bf0578c4.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jbo1_hu_8342d42ee0130fc0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;布尔类型只有两个值，一个是true一个是false&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;说白了要么是真要么是假就这么简单。那么他实际上的值就是0和1了，说白了就是它会把它转换成0和1，它就只有两个值一个是0一个是1，但只占一位。听懂了吗，就这意思。那么如果说我们要用的话很简单了。你玩过游戏是吧，举个例子，比如说以前没有布尔类型的时候我们怎么写呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo2.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo2_hu_bbe84dbb9ec748d3.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jbo2_hu_cad46b9b043691c9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;没有布尔的时候我们会这么写啊&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;也是说当时我这样去写0就代表输了，1就代表通关就是赢了。C99以后呢布尔类型就被引入了，就好办了，我们就不用这样去写了啊。我们就直接这么写&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo3.png&#34;
	width=&#34;1879&#34;
	height=&#34;773&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b014/jbo3_hu_4d5a59b15b70ba15.png 480w, https://airmuamua.github.io/hugoweb/p/b014/jbo3_hu_40039b79dd516224.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;你必须要引入这个头文件才这可以这样去写哦&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当时为毛要这么设计呢，就是因为C语言的这个实际非常依赖于简单还有直接的这些概念，比如说整数，因为基本上还是整数啊。但是你会发现它只有0和1了看到没有，没别的了啊。所以说软件呢越来越复杂代码这也有可读性啊，易维护性啊这需求也在增加，就不能在通常定义成int类型的对吧。所以布尔的这种引入呢，让这个程序变得更加清晰，也就是说C语言在逐渐去适应现代化编程。这是一个比较经典的案例。这就很简单了，你也可以把它理解成布尔类型就是一个开关，大家还记得么，我们就说C语言有很多东西都是开关，一个灯泡的开和关就是开关吗。要么是开要么是关。那么布尔类型就是如此的简单，要么开要么关。它只表达两个东西，要么是true要么是false很简单。这个类型甚至都不用输出的，只需要用就行了，你要真想着输出你就%d你自己去玩了吧。&lt;/p&gt;
&lt;h2 id=&#34;char范围与无符号char&#34;&gt;char范围与无符号char
&lt;/h2&gt;&lt;p&gt;字符值范围呢其实就是-128&lt;del&gt;127之间因为它只占一个字节。但是有人问书记这个char为什么会有无符号类型的，为什么会要有无符号类型的char呢。那既然char只占一个字节那说明它占的小它的值只有-128&lt;/del&gt;127之间。但如果说我们想要的数据非常小，大家知道int类型最小的就是short是吧。那么这种情况呢实际上我跟大家讲。(unsigned以后我简称u_)u_char呢你可以把它理解为是一些简单的东西。比如说画笔，一盒画笔里面可能有八支，那么这个数肯定就是从0&lt;del&gt;255之间了对吧。它甚至都没必要用short，就非常小。你可以这么理解，因为chart它本身来说它存储的时候还是存数字，转化为二进制对不对。它不能存字母字符本质上来说还是数字。那ASCII的话本身存的就是数字转化为二进制，同样的其实char你也可以理解为是一种非常小的整形啊。但是char就是char对吧，后期我们去学char的时候可能用到char []数组我们后面再去学这里先不说。就是我们处理这个文本的时候u_char这个类型可以保证字符永远不是被负数的，你比如说char []我们后面会学的啊，它处理数据的时候它不可能会负数的啊。所以它会有一个无符号的。还有一些处理图像啊处理网络协议当中的一些字节数据的时候它可以直接访问原始字节。然后可能在嵌入式系统当中如果有的人会知道也可以用u_char。就是在前期的时候你很难去理解为什么会有u_char这么一个类型。现在没有办法去讲，就告诉你它有这么一个类型你要知道它它的处理范围就是0&lt;/del&gt;255，只是它处理的范围比较小然后用u_char就行了。它比使用u_int更节省空间。就这意思。但是我们知道我们当时讲int类型的时候我们知道有一个叫uint8_t是吧。所以这个类型你就可以知道了，可以去替代它了。但是你要知道有一个很正常的，就是说我们一般处理int类型数据的时候才会这样去使用就是说我们在处理一些数据的时候我们可能会用char []数组，我们后面会学到，所以这时候可能还会用到u_char。因为无符号的uint类型我们常常用于计算的，就说白了就是我们之前用的uint8_t这个类型它常常用于&lt;strong&gt;数字的计算&lt;/strong&gt;啊。你比如说像这个数值的计算。但是u_char呢它常常用于&lt;strong&gt;字符的处理&lt;/strong&gt;。这就不一样了，两个不同的概念不然的话它不可能分开的。这个细微的差距我们现在没有办法去接触，我只能告诉你这个意思。并不是说u_char完全可以被uint8_t取代的，而是它有它单独的用武之地就像我刚才说的那样。char []数组后面会学。它是专门用来处理数据的。而uint8_t是专门用来计算数据的。这两个完全不一样的概念。假如说你在编写一个网络通信的协议，需要确保这些消息的格式在所有平台和设备上一致，这时候使用uint8可以精确大小类型对吧。保证每个消息都具备完整大小或者结构，这样是可以的。但是你要传输的数据那可能就要用到u_char。后面的话我们在详细去讲，在详细解释它，这个东西你就先知道有一个u_char它有自己单独的用途，而跟那个uint8_t是不一样的，它的用途不一样，根据场景来分。现在没有办法去讲，因为现在要讲的话会很麻烦，你比如日志，日志里面是可以写成u_char的它使用int就不行，就是现在没有办法接触，因为我们现在想要去写这个log这个东西在C语言是一件相当复杂的一件事情是一个有讲究的东西。需要去学完C语言的技术知识到结构体到最后，包括各种各样的知识学的差不多你才能去设计这个东西。后期有机会我再给大家讲。&lt;/p&gt;
&lt;h2 id=&#34;常量const与define宏&#34;&gt;常量const与#define宏
&lt;/h2&gt;&lt;p&gt;这一节讲一个新的知识点叫&lt;strong&gt;常量&lt;/strong&gt;，我们之前讲的都是叫&lt;strong&gt;变量&lt;/strong&gt;。什么叫常量呢，大家都知道变量就是可变的量，那么有些数据它不是变化的，你比如说你买了一把无尽，这个无尽的价格呢不可能是因为你杀人杀的越多这个无尽就便宜了，这不大可能啊。除非游戏官方做了更新把这个无尽价格调整了，但是它调整完之后你这个数你完的时候也不会变啊，你不可能说我打个红buff这无尽他妈就便宜了，我杀了一个人这个无尽就便宜100块，卧槽那还玩个屁啊。所以这个价值就是在整个程序里面是不会变化的，说白了这种量叫做常量。&lt;/p&gt;
&lt;p&gt;那么C语言给定义的常量有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;const int MAX_USERS = 100; //在前面加上const从变量转换为常量，意味着不会发生变化的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;#define PI 3.14 //它不叫常量但它有常量的意思，它可以表达常量，这种有一个专业术语：宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第二章结束语&#34;&gt;第二章结束语
&lt;/h2&gt;&lt;p&gt;其实咱们学了这个数据类型呢，到现在来算就算差不多了，还有人说你还有漏了，漏了一些负数啊虚数啊这些东西没讲啊。这个我为啥没讲呢，因为这个在Visual Studio当中啊哪怕你引入了C99或C11标准或C17标准，它都不能用，这个就比较尴尬啊。所以这个就考虑到就是说跨平台的问题，负数和虚数这个在Windows上使用C语言这种方式是没办法计算的除非引入C++，那这个是没有办法的所以这个暂时不讲了就没有什么意义。&lt;/p&gt;
&lt;p&gt;有兴趣的人可以去研究&amp;lt;complex.h&amp;gt;这个头文件啊。包含标准头文件&amp;lt;complex.h&amp;gt;后，我们就可以用 complex来代表 _Complex，用imaginary来代表 _Imaginary，以及用 I来代表虚数单位 i，也就是 -1的平方根。这里我们就不过多介绍了。&lt;/p&gt;
&lt;p&gt;所以我们这里就布置一个作业，希望大家能够认真去对待，你别傻了啊我又不是学校老师谁检查你还扣你分呢是吧。谁扣你分啊卧槽，没人扣你分，就自己去写啊。大概需要花个10分钟的时间，10分钟的时间自己计时啊。10分钟你要写什么呢，就是你要定义不同的类型你比如说int类型、flout类型、double类型是吧，char类型。就是你自己去定义，所有的类型都定义一下，这是第一个。定义完之后你就赋它一个值，你比如说float最后会有一个f是吧，double可能就最后末尾啥的不说了这个我们都讲过。还有这个所谓的int类型有32位的是吧，int32_t这种你要用uint32_t像这种你要去多定义多写，你就写一个整个的案例。然后呢把它们进行加减乘除，所以这个课后作业留给你们自己去做了啊。需要注意的就是除法，除法的时候你比如说我这个变量是A是float类型是吧，float类型我除以一个整数B，哎，他会出现什么样一种情况，这个大家自己去写一写。我可能要在A前面加上一个(float)，强制类型转换啊。我们需要去注意一下，自己去写，多去写多去锻炼，去练各种各样的输出。作业是一定要有的，我就不推荐给你们什么教材或者说什么练习题那种东西对我们来说没有什么太大的意义。讲实话啊无非就是让你多写，我给你的作业呢就只有一个就是干，没别的。你们自己去定义想怎么就怎么写，你就自己去练。假如说有一天你遇到不会的了，那你正好你这块你没练到，说明你后面还是要去写一写，要想去记住全部的是不太可能的啊，我自己有时候也记不住我也会去查ISO文档或者说微软文档比较简单一点，这是很正常的。没有人会记住那些写东西，谁他妈会记住这些东西啊神经病啊，所以这考试就是不合理的啊根本就不合理。不多说了，就是说考试归考试啊，国内的考试垃圾归垃圾啊，这个ABCDEFG这种命名方式inta、intb这种垃圾归垃圾，但是你要知道你要去练这很重要啊。再说一遍你要去练，不去练不行的。你不能说我喷完它垃圾之后我不练了，那不行。那你碰到它之后垃圾你就想跑了是吧，那不可能的。所以大家要注意，注意这个细节啊。&lt;/p&gt;
&lt;p&gt;OK那我们就给大家布置这个作业大家去写，没人检查你啊，你也别发在评论区，谁他妈检查你卧槽，滚你妈的，自己去做啊，自己去做这个事情，多输出加减乘除各种各样的类型混合操作啊。包括我们之前举出的这些案例是吧，这些还是很经典的，网上可能都没有，包括书上教科书上也没有。敲的时候你要思考，哎是不是有什么东西，哎为什么要这么写，然后你再思考一下啊。你别他妈的有的同学就是他妈的是这样的，左边放个框我写的这个代码，右边呢他就咔嚓咔嚓抄抄抄。抄完之后呢下面还放个小电影是吧，那你说你这样有啥意思呢，你给谁看呢卧槽，你学的东西谁给谁用的，你给我用的吗，给我看的吗，没人他妈的检查你在这上面知道吧，也没有什么所谓的谁给你考试给你分数没有人，我会自己去学啊。你既然能看到我这篇，那我相信你肯定愿意自己去学的，肯定不是开玩笑的是吧。你去认真对待这个问题，你就听我啊，把我们这个综合作业做一下，10分钟15分钟的样子，做完之后呢运行来找一找有没有其他的案例或者是什么的。或者是什么呢，做完我布置的作业之后呢再休息5分钟，定时闹钟定时5分钟之后再准时回来，把我之前数据类型讲的所有的代码再好好的都过一遍，这加深你的印象啊。因为我没有给你们布置什么变态的题目，什么inta、intb来回去算没意思那种题。怎么计算机都算了我们还算什么呢，卧槽你这算了个计算机我都不信。所以这个就没什么意思啊，就是说这个不能去锻炼自己的这个代码量啊，很多同学就说光做题牛逼但一叫他写代码写程序他傻逼卧槽，就这种挺多的啊。所以大家要清楚啊，我给大家着重强调练习大量的练习，一定要确保你对数据类型有充足的认知，尤其是int类型啊，你说我忘记了什么这个那个的原理，你忘记了可以但是你这个int类型你不能忘记啊，我写那老多，你忘记这个那就有点过分啊。&lt;/p&gt;
&lt;p&gt;好了第二章到这就结束了，咱这学的就是章法连篇的，一会又是卧槽的这才是C语言是吧，那老师讲的那是什么，中文。没别的只有这个意思。咱们还是亲切一点啊，就是很骂人啊飙脏话这种东西很少能在公共场合让大家去说，我相信有一天如果真的有一些比如说在大学社团啊，大学社团真的没什么屌用啊，讲实话啊就假如说有老师，假如说有大学教授在课堂上整这些让大家去看那我觉得很牛逼，卧槽应该不会真的有人这样去做啊，那我觉得你牛逼，我跟你讲你绝对为中国的教育做出了一份贡献我可以这么跟你讲。我没做出贡献了做出贡献的人是你啊。因为你敢把我这种带到课堂上，那我觉得你很牛逼不是我牛逼是吧就这个意思。好了到此为止，大家一定要好好去练习，然后休息一段时间，假如说今天就看完了数据类型了看到最后一章了你今天就可以休息了就不要再看了，哪怕说你今天还有一下午的学习时间都不要再看了。你需要去练习，因为你练习还有花时间，练习完之后你就可以休息了。休息之后咱明天再去做接下来的学习啊。我希望是这样的一个过程，但最好不要去拖延，有人说拖延到明天了，然后后天就不学了大后天人也不见了然后跑去打英雄联盟去了这种常见的啊。&lt;/p&gt;
&lt;h3 id=&#34;开骂题外话&#34;&gt;（开骂）题外话
&lt;/h3&gt;&lt;p&gt;所以我在后面经常说一句话，说有些人我就觉得搞笑它跟我说没有时间学习，我说你没有时间学习那以后你他妈的以后上班是不是赚钱的时候你说你要还贷款你说，哎我没有时间赚钱。这就很搞笑是吧，我就觉得这个说法很搞笑。你今天说你没有时间学习那你明天就可以说没有时间赚钱是吧，后天就可以说我没有时间吃饭啊。很显而易见的，没什么好说的，祝大家好运。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【C/C&#43;&#43;】C语言「第一章」</title>
        <link>https://airmuamua.github.io/hugoweb/p/b013/</link>
        <pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b013/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b013/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BB%A3%E7%A0%81-%E5%88%9B%E6%84%8F%E7%BC%96%E7%A0%81.png" alt="Featured image of post 【C/C&#43;&#43;】C语言「第一章」" /&gt;&lt;h2 id=&#34;第一章&#34;&gt;第一章
&lt;/h2&gt;</description>
        </item>
        <item>
        <title>【教程】VS环境搭建</title>
        <link>https://airmuamua.github.io/hugoweb/p/b004/</link>
        <pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b004/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b004/c.png" alt="Featured image of post 【教程】VS环境搭建" /&gt;&lt;h2 id=&#34;环境准备&#34;&gt;环境准备
&lt;/h2&gt;&lt;h3 id=&#34;visual-studio下载&#34;&gt;Visual Studio下载
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;前往【&lt;a class=&#34;link&#34; href=&#34;https://visualstudio.microsoft.com/zh-hans/downloads/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Visual Studio官网&lt;/a&gt;】，下载Community版安装程序&lt;/li&gt;
&lt;li&gt;一直点下一步，默认安装即可(更改文件位置咨询我)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【数学】高等数学</title>
        <link>https://airmuamua.github.io/hugoweb/p/b007/</link>
        <pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>https://airmuamua.github.io/hugoweb/p/b007/</guid>
        <description>&lt;img src="https://airmuamua.github.io/hugoweb/p/b007/yj2.png" alt="Featured image of post 【数学】高等数学" /&gt;&lt;h2 id=&#34;高等数学&#34;&gt;高等数学
&lt;/h2&gt;&lt;h3 id=&#34;极限与连续&#34;&gt;极限与连续
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs1.jpg&#34;
	width=&#34;2452&#34;
	height=&#34;3538&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs1_hu_6c04fd84391116dc.jpg 480w, https://airmuamua.github.io/hugoweb/p/b007/gs1_hu_fbf3b15524c6d0eb.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;极限与连续&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;69&#34;
		data-flex-basis=&#34;166px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;导数与微分&#34;&gt;导数与微分
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs2.jpg&#34;
	width=&#34;2112&#34;
	height=&#34;2980&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs2_hu_8d70d6721130ce8c.jpg 480w, https://airmuamua.github.io/hugoweb/p/b007/gs2_hu_a4abf6f66c0c9707.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;导数与微分&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;170px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;微分中值定理&#34;&gt;微分中值定理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs3.jpg&#34;
	width=&#34;2228&#34;
	height=&#34;3400&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs3_hu_5e9f435e63d1f54d.jpg 480w, https://airmuamua.github.io/hugoweb/p/b007/gs3_hu_248a72cd0706bad4.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;微分中值定理&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;导数几何应用&#34;&gt;导数几何应用
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs4.jpg&#34;
	width=&#34;2088&#34;
	height=&#34;4764&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs4_hu_d3cf91293caae066.jpg 480w, https://airmuamua.github.io/hugoweb/p/b007/gs4_hu_c9a873692c7616f7.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;导数几何应用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;43&#34;
		data-flex-basis=&#34;105px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;公式表&#34;&gt;公式表
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs5.jpg&#34;
	width=&#34;1483&#34;
	height=&#34;4096&#34;
	srcset=&#34;https://airmuamua.github.io/hugoweb/p/b007/gs5_hu_df7cd6db39fc8f47.jpg 480w, https://airmuamua.github.io/hugoweb/p/b007/gs5_hu_98e7b4e131c057d3.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;公式表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;36&#34;
		data-flex-basis=&#34;86px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;以上均来自B站&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/1035929235&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一高数&lt;/a&gt;的&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1CC4y1T72s/?spm_id_from=333.1387.search.video_card.click&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【&lt;em&gt;高等数学&lt;/em&gt;(上)】期末3小时通关！考点公式全面梳理+考试锦囊（上集）&lt;/a&gt;有兴趣的可以自己去看。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
